<h1 align="center">Design Patterns in C#</h1>

## ğŸ’» Project
Esse projeto tem como objetivo estudar Design Patterns implementados em C#. Ele contÃ©m teoria e a implementaÃ§Ã£o do cÃ³digo.
This project has the goal to study design patterns implemented in C#. It's contain theory and code implementation.

## Structural

### Adapter ###
Adapter Ã© um padrÃ£o de projeto estrutural que permite que classes incompatÃ­veis se comuniquem. Ele tambÃ©m serve como uma camada anticorrupÃ§Ã£o que permite desacoplamento.
Exemplos:
- Diferentes implementaÃ§Ãµes de gateway que tem que se comunicar com seu domÃ­nio que tem diferentes interfaces.
- Quando vocÃª tem cÃ³digo legado e precisa adaptar para classes modernas.

**PROS**
- Responsabilidade Ãºnica: Separar diferentes dados das regras de negÃ³cio.
- PrincÃ­pio do aberto fechado: VocÃª consegue introduzir novos adaptadores sem quebrar os clientes existentes, contanto que o contrato da interface seja preservada.

**CONS**
- A complexidade do cÃ³digo aumenta porque Ã© introduzido muitas novas interfaces e classes.

**Como implementa?**
- Cria uma interface que descreve o contrato que outras classes devem seguir.

```
namespace DesignPatterns.Structural.Adapter.Adapter_Transaction
{
    public interface ITransaction
    {
        public string TrackNumber { get; }
        public decimal Amount { get; }
        public string Status { get; }
    }
}
```

- Criar as classes desejadas.
- Criar o adaptador para as classes desejadas que vÃ£o implementar a interface.
- Adicionar a referÃªncia da classe que vocÃª precisar adaptar na sua classe adaptadora. Ã‰ comum usar o construtor, mas vocÃª pode chamar quando chamar o mÃ©todo das suas classes.
---

## Behavioral

### Chain of Responsability ###
- Cadeia de responsabilidade Ã© um design pattern comportamental que permite que passem as requisiÃ§Ãµes adiante, como uma cadeia. E cada requisiÃ§Ã£o/handle decide o que vai ser feito na cadeia.
- Especialmente Ãºtil quando tem que executar passos em sequÃªncia.
- Os handlers sÃ£o conectados a uma cadeia e cada conexÃ£o do handler tem um campo que guarda a referÃªncia para o prÃ³ximo handler.
Examples:
- Quando vocÃª quer oferecer um cartÃ£o de crÃ©dio, mas precisa executar diversas validaÃ§Ãµes antes para saber se a pessoa Ã© elegÃ­vel.
- Quando vocÃª precisa verificar se os usuÃ¡rios estÃ£o autenticados e autorizados para acessar o sistema. EntÃ£o, vocÃª pode usar cadeia de responsabilidade, quando o request Ã© criado e executado em sequÃªncia o processo de autenticaÃ§Ã£o.

**PROS**
- Controlar a ordem de execuÃ§Ã£o do request.
- Responsabilidade Ãšnica: Desacople classes que invocam operaÃ§Ã£o de classes que performam operaÃ§Ãµes.
- PrincÃ­pio do aberto fechado: Introduza novos handlers sem quebrar o cÃ³digo cliente jÃ¡ existente.

**CONS**
- Risco de criar uma cadeia infinita.
- DepuraÃ§Ã£o pode ser mais difÃ­cil.
- A configuraÃ§Ã£o da cadeia pode ser complexa.

**Como implementar?**
- Declare a interface do handler e descreva a assinatura do seu mÃ©todo para lidar com as requisiÃ§Ãµes do handler. VocÃª pode converter as requisiÃ§Ãµes em um objeto e passar o mÃ©todo do handler como um argumento.
- Para eliminar cÃ³digo duplicado em handlers concretos, vocÃª pode criar uma classe abstrata base, derivada da interface do handler. Essa classe contÃ©m uma referÃªncia ao **prÃ³ximo handler** na cadeia. Considere fazer essa classe imutÃ¡vel, mas se vocÃª precisa modificar cadeias em tempo de execuÃ§Ã£o, vocÃª precisa definir um setter para alterar o campo de referÃªncia. AlÃ©m disso, vocÃª vai precisar criar um comportamento padrÃ£o para o mÃ©todo do handler, que Ã© passar o request para o prÃ³ximo objeto a menos que nÃ£o haja objeto. Handlers concretos poderÃ£o usar isso chamando o mÃ©todo pai.
- VocÃª pode criar suas prÃ³prias cadeias, receber cadeias prÃ© construÃ­das de outros objetos ou implementar algumas classes factory para construir a cadeia.
- Clientes devem estar preparados para os seguintes cenÃ¡rios: a cadeia consiste de um Ãºnico link, aguns request nÃ£o devem seguir ao fim da cadeia e outras podem chegar ao fim da cadeia sem tratamento.

### Visitor ###
- Visitor Ã© uma padrÃ£o de projeto comportamental que executa uma operaÃ§Ã£o em uma lista de objetos diferentes da mesma classe mÃ£e.
- Ã‰ usado quando vocÃª tem diferentes objetos dentro de uma lista ou Ã¡rvore.

**PROS**
- PrincÃ­pio do aberto fechado: porque vocÃª pode introduzir novos comportamentos para objetos especÃ­ficos sem mudar a classe pai.
- PrincÃ­pio da responsabilidade Ãºnica: porque vocÃª pode separar comportamento com sua classe respectiva.
- Visitor pode acumular informaÃ§Ãµes e ser muito Ãºtil quando se trabalha com nÃ³s de Ã¡rvore.

**CONS**
- VocÃª precisa atualizar todos os visitors quando uma classe Ã© modificada na hierarquia.
- Visitors podem nÃ£o ter os acessos necessÃ¡rios para campos privados ou mÃ©todos.

**Como implementar?**
- Declare uma interface visitor com mÃ©todos visits, uma para elemento concreto da classe.
- Declare uma classe abstrata ou uma interface com os mÃ©todos Accept que irÃ£o receber objetos visitors como argumento.
- Implemente os mÃ©todos Accept em todas as classes concretas. Esses mÃ©todos irÃ£o redirecionar cada chamada do objeto visitor como um argumento.
- As classes de elementos somente trabalham com o visitor via interface do visitor. Visitors devem saber de todas os elementos concretos da classe como tipos de parÃ¢metro.
- Para cada comportamento na lista ou Ã¡rvore, vocÃª tem que criar uma classe concreta do visitor e implementar os mÃ©todos visits.
- O cliente deve criar objetos visitors e passÃ¡-los para elementos por meio de mÃ©todos de aceitaÃ§Ã£o.

## ğŸ§ª Techs

This project was develop with the following technologies:

- [.NET 7 Console Application](https://docs.microsoft.com/pt-br/dotnet/core/dotnet-7)

## How can I use?

You will need of the Visual Studio 2022 and .NET 7 SDK.
This SKDs and tools can be download in .NET 7 https://dot.net/core.
You can execute in Visual Studio Code too (Windows, Linux or MacOS)

## ğŸš€ How can I execute?

Clone the projet and access the pasta.

```bash
$ git clone https://github.com/rafaelaccampos/design-patterns-in-csharp
$ cd DesignPatterns
# To install the dependencies
$ dotnet restore


```

To initiate the tests, follow the steps below:
```bash
$ dotnet test
```


