<h1 align="center">Design Patterns in C#</h1>

## üíª Project
Esse projeto tem como objetivo estudar Design Patterns implementados em C#. Ele cont√©m teoria e a implementa√ß√£o do c√≥digo.
This project has the goal to study design patterns implemented in C#. It's contain theory and code implementation.

## Creational

### Builder ###
- Builder √© um padr√£o de projeto criacional que permite que voc√™ crie objetos complexos em v√°rias etapas.
- Especialmente √∫til quando se tem muitos par√¢metros opcionais ou quando voc√™ precisa criar o objeto por partes.

**Exemplos**:
- Formul√°rios muito grandes que s√£o constru√≠dos em diversas etapas.
- Na cria√ß√£o de objetos de testes em que voc√™ s√≥ precisa criar com par√¢metros espec√≠ficos.

**PROS**
- Voc√™ consegue construir objetos complexos passo a passo.
- Responsabilidade √∫nica: Separar constru√ß√µes complexas de objetos de l√≥gica de neg√≥cios.
- Voc√™ pode reusar os builders para diferentes cria√ß√µes de produto.
- Evita o code smell telescoping constructor. O code smell telescoping constructor √© quando uma classe tem v√°rios construtores com muitos par√¢metros e isso dificulta saber a ordem dos par√¢metros, bem como qual √© o construtor certo a ser utilizado.

**CONS**
- A complexidade do c√≥digo aumenta porque voc√™ precisa criar m√∫ltiplas classes.

**Como implementa?**
- Identifique claramente todos os passos de constru√ß√£o para construir todas as representa√ß√µes do produto dispon√≠veis.
- Declare esses passos na interface do builder.
- Crie uma classe construtora concreta para cada uma das representa√ß√µes do produto e implemente suas etapas de constru√ß√£o.
- Implemente um m√©todo (nesse caso, Generate) para buscar o resultado da constru√ß√£o.

```csharp
using System.Text;

namespace DesignPatterns.Creational.Builder
{
    public class ItemBuilder
    {
        public ItemBuilder(
            int idItem, 
            string category, 
            string description, 
            decimal price)
        {
            IdItem = idItem;
            Category = category;
            Description = description;
            Price = price;
        }

        public int IdItem { get; private set; }

        public string Category { get; private set; }

        public string Description { get; private set; }

        public decimal Price { get; private set; }

        public decimal Width { get; private set; }

        public decimal Height { get; private set; }

        public decimal Length { get; private set; }

        public decimal Weight { get; private set; }


        public ItemBuilder WithWidth(decimal width)
        {
            Width = width;
            return this;
        }

        public ItemBuilder WithHeight(decimal height)
        {
            Height = height;
            return this;
        }

        public ItemBuilder WithLenght(decimal lenght)
        {
            Length = lenght;
            return this;
        }

        public ItemBuilder WithWeight(decimal weight)
        {
            Weight = weight;
            return this;
        }

        public Item Generate()
        {
            var item = new Item(this);
            return item;
        }
    }
}

namespace DesignPatterns.Creational.Builder
{
    public class Item
    {
        public Item(ItemBuilder itemBuilder)
        {
            IdItem = itemBuilder.IdItem;
            Category = itemBuilder.Category;
            Description = itemBuilder.Description;
            Width = itemBuilder.Width;
            Height = itemBuilder.Height;
            Length = itemBuilder.Length;
            Weight = itemBuilder.Weight;
        }

        public int IdItem { get; private set; }

        public string Category { get; private set; }
        
        public string Description { get; private set; }
        
        public decimal? Width { get; private set; }
        
        public decimal? Height { get; private set; }
        
        public decimal? Length { get; private set; }
        
        public decimal? Weight { get; private set; }

        public decimal? GetVolume()
        {
            if(Width == null || Height == null || Length == null) return 0;

            return Width / 100 * Height / 100 * Length / 100;
        }

        public decimal? GetDensity()
        {
            if(Width == null || Height == null || Length == null || Height == null || Weight == null) return 0;

            return Weight / GetVolume();
        }
    }
}

using DesignPatterns.Creational.Builder;
using FluentAssertions;

namespace DesignPatterns.Tests.Builder
{
    public class ItemTests
    {
        [Test]
        public void ShouldBeAbleToCreateAnItem()
        {
            var item = new ItemBuilder(1, "Instrumentos Musicais", "Guitarra", 1000)
                .WithWidth(100)
                .WithHeight(50)
                .WithLenght(30)
                .WithWeight(3)
                .Generate();

            var volume = item.GetVolume();

            volume.Should().Be(0.15M);
        }
    }
}
```

### Factory Method ###
- Factory Method √© um padr√£o de projeto criacional que prov√™ uma interface comum para cria√ß√£o de um objeto, e permite que as subclasses alterem o tipo do objeto que vai ser executado, ou seja, delega a responsabilidade de instanciar objetos para as classes concretas.
- Especialmente √∫til quando h√° algum processamento gen√©rico em uma classe, mas as subclasses s√£o decididas dinamicamente no per√≠odo de execu√ß√£o.
- Geralmente usado quando existe comportamento polim√≥rfico.

**Exemplos**:
- Uma aplica√ß√£o que precisa gerenciar diferents tipos de documento (Word, PDF).
- Uma aplica√ß√£o que precisa gerenciar diferentes tipos de pagamento (Boleto, Cart√£o de Cr√©dito, PayPal).

**PROS**
- Voc√™ evita um acoplamento forte entre a cria√ß√£o dos objetos e as classes concretas.
- Princ√≠pio da responsabilidade √∫nica: Voc√™ consegue a cria√ß√£o do objeto em um √∫nico lugar.
- Princ√≠pio do aberto fechado: Voc√™ consegue introduzir novos objetos sem criar os j√° existentes.

**CONS**
- O c√≥digo pode ser mais complexo j√° que voc√™ precisa criar novas classes para cada tipo de objeto a ser instanciado para implementar o padr√£o de projeto.

**Como implementa?**
- Defina a interface comum para o servi√ßo que ser√° implementada pelos outros servi√ßos.

```csharp
namespace DesignPatterns.Creational.Factory_Method
{
    public interface IPaymentService
    {
        object Process(OrderItem orderItem);
    }
}
```

- Implemente os servi√ßos concretos que herdaram da interface.

```csharp
namespace DesignPatterns.Creational.Factory_Method
{
    public class CreditCardService : IPaymentService
    {
        public object Process(OrderItem orderItem)
        {
            return "Transa√ß√£o aprovada!";
        }
    }

    public class PaymentSlipService : IPaymentService
    {
        public object Process(OrderItem orderItem)
        {
            return "Dados do boleto";
        }
    }
}
```

- Defina a interface da factory.

```csharp
namespace DesignPatterns.Creational.Factory_Method
{
    public interface IPaymentServiceFactory
    {
        IPaymentService GetService(PaymentMethod paymentMethod);
    }
}
```

- Implemente a f√°brica que cria inst√¢ncias dos servi√ßos.

```csharp
namespace DesignPatterns.Creational.Factory_Method
{
    public class PaymentServiceFactory : IPaymentServiceFactory
    {
        private static readonly IDictionary<PaymentMethod, IPaymentService> paymentServices = new Dictionary<PaymentMethod, IPaymentService>()
        {
            { PaymentMethod.CreditCard, new CreditCardService() },
            { PaymentMethod.PaymentSlip, new PaymentSlipService() }
        };

        public IPaymentService GetService(PaymentMethod paymentMethod)
        {
            if (!paymentServices.TryGetValue(paymentMethod, out var service))
            {
                throw new InvalidOperationException("Payment Method not found!");
            }

            return service;
        }
    }
}
```

- Define a classe que vai orquestrar a factory method.

```csharp
namespace DesignPatterns.Creational.Factory_Method
{
    public class OrderItem
    {
        public Guid ProductId { get; set; }
        public int Quantity { get; set; }
        public PaymentMethod PaymentMethod { get; set; }
    }
}

namespace DesignPatterns.Creational.Factory_Method
{
    public enum PaymentMethod
    {
        CreditCard = 1,
        PaymentSlip = 2,
    }
}

namespace DesignPatterns.Creational.Factory_Method
{
    public class Order
    {
        private readonly IPaymentServiceFactory _paymentServiceFactory;

        public Order(IPaymentServiceFactory paymentServiceFactory)
        {
            _paymentServiceFactory = paymentServiceFactory;
        }

        public void Create(OrderItem orderItem)
        {
            var paymentService = _paymentServiceFactory.GetService(orderItem.PaymentMethod);
            paymentService.Process(orderItem);
        }
    }
}
```

- Defina a classe cliente que vai utilizar a factory.

```csharp
namespace DesignPatterns.Tests
{
    public class OrderTests
    {
        [Fact]
        public void ShouldProcessOrderWithCreditCardService()
        {
            var factory = new PaymentServiceFactory();
            var order = new Order(factory);
            var orderItem = new OrderItem
            {
                ProductId = Guid.NewGuid(),
                Quantity = 1,
                PaymentMethod = PaymentMethod.CreditCard
            };

            order.Create(orderItem);

            var service = factory.GetService(orderItem.PaymentMethod);
            var creditCard = service.Process(orderItem);
            Assert.Equal("Transa√ß√£o aprovada!", result);
        }

        [Fact]
        public void Create_ShouldProcessOrderWithPaymentSlipService()
        {
            var factory = new PaymentServiceFactory();
            var order = new Order(factory);
            var orderItem = new OrderItem
            {
                ProductId = Guid.NewGuid(),
                Quantity = 1,
                PaymentMethod = PaymentMethod.PaymentSlip
            };

            order.Create(orderItem);

            var service = factory.GetService(orderItem.PaymentMethod);
            var paymentSlip = service.Process(orderItem);
            Assert.Equal("Dados do boleto", result);
        }
    }
}
```

### Abstract Factory ###
- O Abstract Factory √© um padr√£o de projeto criacional que permite que voc√™ tenha fam√≠lias de projetos relacionados sem criar classes concretas.
- Use Abstract Factory quando seu c√≥digo precisar trabalhar com diversas fam√≠lias de produtos relacionados.
- Quando uma classe lida com m√∫ltiplos tipos de produto pode valer a pena implementar o Abstract Factory.

**Exemplos**
- Escolher tema light ou dark, pois voc√™ precisa de um conjunto de elementos compat√≠vel com o tema escolhido.
- Escolha de m√≥veis modernos ou vitorianos, pois voc√™ precisa que seja criado elementos de acordo com o tipo de m√≥vel escolhido.
- Para cria√ß√£o de m√∫ltiplos reposit√≥rios (que s√£o passados pelo construtor).

**PROS**
- Os produtos que voc√™ obt√©m de um abstract factory s√£o compat√≠veis entre si.
- Evita v√≠nculo forte entre implementa√ß√µes concretas e o c√≥digo do cliente.
- Princ√≠pio da responsabilidade √∫nica: √â poss√≠vel extrair o c√≥digo de cria√ß√£o de produtos para um √∫nico lugar.
- Princ√≠pio do aberto e fechado: √â poss√≠vel introduzir novos produtos sem quebrar o c√≥digo cliente j√° existente.

**CONS**
- O c√≥digo se torna mais complexo porque s√£o adicionadas muitas interfaces e classes juntos com o padr√£o.

**Como implementar?**
- Mapeie os produtos distintos e as variantes desses produtos.
- Declare interface de produto abstratas para todos os tipos de produto. Ent√£o, fa√ßa com que as classes concretas de produtos implementem essas interfaces.

```csharp
namespace DesignPatterns.Structural.Abstract_Factory
{
    public interface IButton
    {
        string Color { get; }
        string BackgroundColor { get; }
    }
}
namespace DesignPatterns.Structural.Abstract_Factory
{
    public interface ILabel
    {
        string Color { get; }
    }
}

namespace DesignPatterns.Structural.Abstract_Factory
{
    public class DarkButton : IButton
    {
        public DarkButton()
        {
            Color = "white";
            BackgroundColor = "black";
        }

        public string Color { get; private set; }

        public string BackgroundColor { get; private set; }
    }
}
namespace DesignPatterns.Structural.Abstract_Factory
{
    public class LightButton : IButton
    {
        public LightButton()
        {
            Color = "white";
            BackgroundColor = "blue";
        }

        public string Color { get; private set; }

        public string BackgroundColor { get; private set; }
    }
}
namespace DesignPatterns.Structural.Abstract_Factory
{
    public class DarkLabel : ILabel
    {
        public DarkLabel()
        {
            Color = "white";
        }

        public string Color { get; private set; }
    }
}
namespace DesignPatterns.Structural.Abstract_Factory
{
    public class LightLabel : ILabel
    {
        public LightLabel()
        {
            Color = "black";
        }

        public string Color { get; private set; }
    }
}
```

- Implemente um conjunto de classes f√°bricas concretas, uma para cada variante de produto.

```csharp
namespace DesignPatterns.Structural.Abstract_Factory
{
    public interface IAbstractWidgetFactory
    {
        ILabel CreateLabel();
        IButton CreateButton();
    }
}
namespace DesignPatterns.Structural.Abstract_Factory
{
    public class DarkThemeFactory : IAbstractWidgetFactory
    {
        public ILabel CreateLabel()
        {
            return new DarkLabel();
        }

        public IButton CreateButton()
        {
            return new DarkButton();
        }
    }
}
namespace DesignPatterns.Structural.Abstract_Factory
{
    public class LightThemeFactory : IAbstractWidgetFactory
    {
        public ILabel CreateLabel()
        {
            return new LightLabel();
        }

        public IButton CreateButton()
        {
            return new LightButton();
        }
    }
}
```

- Crie um c√≥digo de inicializa√ß√£o da f√°brica. Ele deve instanciar uma das classes f√°bricas concretas, dependendo da configura√ß√£o da aplica√ß√£o ou do ambiente atual. Passe esse objeto f√°brica para todas as classes que constroem produtos.
- Substitua todas as chamadas diretas aos construtores do produto e chame o m√©todo de cria√ß√£o apropriado no objeto f√°brica.

```csharp
namespace DesignPatterns.Structural.Abstract_Factory
{
    public class View
    {
        public View(IAbstractWidgetFactory abstractWidgetFactory)
        {
            Label = abstractWidgetFactory.CreateLabel();
            Button = abstractWidgetFactory.CreateButton();
        }

        public ILabel Label { get; private set; }
        public IButton Button { get; private set; }
    }
}
using DesignPatterns.Structural.Abstract_Factory;
using FluentAssertions;
using FluentAssertions.Execution;

namespace DesignPatterns.Tests.AbstractFactory
{
    public class ViewTests
    {
        [Test]
        public void ShouldBeAbleToCreateAViewWithLightTheme()
        {
            var view = new View(new LightThemeFactory());

            using(new AssertionScope())
            {
                view.Label.Color.Should().Be("black");
                view.Button.Color.Should().Be("white");
                view.Button.BackgroundColor.Should().Be("blue");
            }
        }

        [Test]
        public void ShouldBeAbleToCreateAViewWithDarkTheme()
        {
            var view = new View(new DarkThemeFactory());

            using (new AssertionScope())
            {
                view.Label.Color.Should().Be("white");
                view.Button.Color.Should().Be("white");
                view.Button.BackgroundColor.Should().Be("black");
            }
        }
    }
}
```

### Prototype ###
- Prototype √© um padr√£o de projeto criacional que permite copiar objetos sem depender das suas classes.
- Permite que voc√™ clone objetos privados sem a depend√™ncia da classe concreta, ao contr√°rio da abordagem direta passando campo a campo para um novo objeto.
- Delega o processo de clonagem para o pr√≥prio objeto.
- Utilize o padr√£o quando seu c√≥digo n√£o puder depender da classe concreta que voc√™ deseja copiar.
- Utilize o padr√£o quando voc√™ tem muitas subclasses que s√≥ diferem na forma que inicializam seus objetos.
- O padr√£o pode ser √∫til para quando voc√™ precisa salvar c√≥pias de comandos (Command - padr√£o de projeto) no hist√≥rico.
- Algumas vezes pode ser uma alternativa ao padr√£o de projeto Memento.

**Exemplos**:
- Editor de gr√°ficos ou imagens, pois pode ser feita a c√≥pia de c√≠rculos, quadrados, linhas e etc.
- Algumas configura√ß√µes da aplica√ß√£o pesadas podem se benefeciar do uso do Prototype para um carregamento mais r√°pido.
- Jogos, pois voc√™ pode copiar as caracter√≠sticas de um personagem.
- Sistemas de gerenciamento de documentos, pois muitas vezes esses documentos tem pequenas varia√ß√µes.

**PROS**
- Clonar objetos sem depend√™ncia da classe concreta.
- Evitar c√≥digos de inicializa√ß√£o repetidos.
- Facilidade para constru√ß√£o de objetos complexos.

**CONS**
- Clonar objetos com refer√™ncias circulares pode ser dif√≠cil.

**Como implementa?**
- Crie a interface do Prototype com um m√©todo clone.

```csharp
namespace DesignPatterns.Creational.Prototype
{
    public interface IVehiclePrototype
    {
        IVehiclePrototype Clone();
    }
}
```

- Uma classe Prototype deve definir o construtor alternativo que aceita os objetos da classe como argumento. O construtor deve copiar os valores de todos os campos definidos na classe do objeto passado para a nova inst√¢ncia.
- O m√©todo de clonagem consiste em uma linha executando um operador new com a vers√£o do prot√≥tipo do construtor ou no nosso caso, usando o m√©todo MemberWiseClone para clonar o objeto.

```csharp
namespace DesignPatterns.Creational.Prototype
{
    public class Car : IVehiclePrototype
    {
        public string Model { get; private set; }

        public string Color { get; private set; }

        public int Seats { get; private set; }

        public Car(string model, string color, int seats)
        {
            Model = model;
            Color = color;
            Seats = seats;
        }

        public IVehiclePrototype Clone()
        {
            return (IVehiclePrototype)MemberwiseClone();
        }

        public void SetColor(string color)
        {
            Color = color;
        }

        public override string ToString()
        {
            return $"Car: {Model}, Color: {Color}, Seats: {Seats}";
        }
    }
}

using DesignPatterns.Creational.Prototype;
using FluentAssertions;
using FluentAssertions.Execution;

namespace DesignPatterns.Tests.Prototype
{
    public class CarTests
    {
        [Test]
        public void ShouldBeAbleToCloneAnExactlyCopyOfTheCar()
        {
            var car = new Car("Toyota Camry", "Red", 5);

            var clonedCar = car.Clone() as Car;

            using (new AssertionScope())
            {
                car.Model.Should().Be(clonedCar!.Model);
                car.Color.Should().Be(clonedCar.Color);
                car.Seats.Should().Be(clonedCar.Seats);
            }
        }

        [Test]
        public void ShouldBeAbleToCloneAndModifyWithoutAffectingTheOriginalCar()
        {
            var car = new Car("Toyota Camry", "Red", 5);

            var clonedCar = car.Clone() as Car;
            clonedCar!.SetColor("Blue");

            using (new AssertionScope())
            {
                car.Color.Should().Be("Red");
                clonedCar.Color.Should().Be("Blue");
            }
        }
    }
}
```
### Singleton ###
- O Singleton √© um padr√£o de projeto criacional que permite que a classe tenha apenas uma inst√¢ncia, enquanto prov√™ um ponto de acesso global para cada inst√¢ncia.
- Utilize o padr√£o Singleton quando uma classe deve ter apenas uma inst√¢ncia dispon√≠vel.
- Utilize o padr√£o quando voc√™ quiser um controle mais estrito sobre as vari√°veis globais.

**Exemplos**
- Configura√ß√µes do sistema.
- Conex√µes com o banco de dados.
- Escrita de logs.

**PROS**
- Garantia de que a classe s√≥ vai ter uma inst√¢ncia.
- Acesso global a inst√¢ncia.
- O objeto √© inicializado somente quando √© chamado pela primeira vez.

**CONS**
- Viola o princ√≠pio da responsabilidade √∫nica, pois resolve dois problemas de uma vez s√≥: garantir que uma classe s√≥ tenha uma inst√¢ncia e fornece um ponto de acesso global a inst√¢ncia.
- Pode fazer com que as classes do programa conhe√ßam muito sobre cada uma.
- Requer cuidado quando est√° se trabalhando com multithread, pois pode criar o objeto Singleton m√∫ltiplas vezes.
- Pode ser dif√≠cil de testar, uma vez que oculta o construtor privado e muitos frameworks utilizam heran√ßa para produzirem objetos simulados.

**Como implementar?**
- Adicione um campo privado est√°tico para o armazenamento da inst√¢ncia Singleton.
- Declare um m√©todo de cria√ß√£o p√∫blico est√°tico para obter a inst√¢ncia do Singleton.
- Fa√ßa o construtor "vazio" ser privado.

```csharp
namespace DesignPatterns.Creational.Singleton
{
    public class BusinessHours
    {
        private static BusinessHours _instance = null!;
        
        private BusinessHours(DateTime startTime, DateTime endTime)
        {
            StartTime = startTime;
            EndTime = endTime;
        }


        public DateTime StartTime { get; private set; }

        public DateTime EndTime { get; private set; }

        public static BusinessHours GetInstance()
        {
            if (_instance == null)
            {
                _instance = new BusinessHours(
                    new DateTime(1, 1, 1, new Random().Next(0, 10), 0, 0),
                    new DateTime(1, 1, 1, new Random().Next(18, 24), 0, 0)
                    );
            }

            return _instance;
        }
    }
}
```

- Mude todas as chamadas diretas para o construtor do Singleton chamando o m√©todo de cria√ß√£o est√°tico.

```csharp
using DesignPatterns.Creational.Singleton;
using FluentAssertions;

namespace DesignPatterns.Tests.Singleton
{
    public class BusinessHoursTests
    {
        [Test]
        public void ShouldBeAbleToGetAnInstance()
        {
            var instance = BusinessHours.GetInstance();
            
            instance.Should().NotBeNull();
        }

        [Test]
        public void ShouldBeAbleToCheckIfInstancesAreTheSame()
        {
            var firstIntance = BusinessHours.GetInstance();
            var secondIntance = BusinessHours.GetInstance();

            firstIntance.Should().Be(secondIntance);
        }
    }
}
```

## Structural

### Adapter ###
- Adapter √© um padr√£o de projeto estrutural que permite que classes incompat√≠veis se comuniquem. Ele tamb√©m serve como uma camada anticorrup√ß√£o que permite desacoplamento.

**Exemplos**:
- Diferentes implementa√ß√µes de gateway que tem que se comunicar com seu dom√≠nio que tem diferentes interfaces.
- Quando voc√™ tem c√≥digo legado e precisa adaptar para classes modernas.

**PROS**
- Responsabilidade √∫nica: Separar diferentes dados das regras de neg√≥cio.
- Princ√≠pio do aberto fechado: Voc√™ consegue introduzir novos adaptadores sem quebrar os clientes existentes, contanto que o contrato da interface seja preservada.

**CONS**
- A complexidade do c√≥digo aumenta porque √© introduzido muitas novas interfaces e classes.

**Como implementar?**
- Cria uma interface que descreve o contrato que outras classes devem seguir.

```csharp
namespace DesignPatterns.Structural.Adapter.Adapter_Transaction
{
    public interface ITransaction
    {
        public string TrackNumber { get; }
        public decimal Amount { get; }
        public string Status { get; }
    }
}
```

- Criar as classes desejadas.

```csharp
    public class PaypalTransaction
    {
        public PaypalTransaction(int id, int amount, string status)
        {
            Id = id;
            Amount = amount;
            Status = status;
        }

        public int Id { get; private set; }
        public decimal Amount { get; private set; }
        public string Status { get; private set; }
    }
```
```csharp
    public class StripeTransaction
    {
        public StripeTransaction(string code, decimal grossAmount, int situation)
        {
            Code = code;
            GrossAmount = grossAmount;
            Situation = situation;
        }

        public string Code { get; private set; }
        public decimal GrossAmount { get; private set; }
        public int Situation { get; private set; }
    }
```
- Criar o adaptador para as classes desejadas que v√£o implementar a interface.

```csharp
    public class PayPalTransactionAdapter : ITransaction
    {
        public PayPalTransactionAdapter(PaypalTransaction payPalTransaction)
        {
            TrackNumber = payPalTransaction.Id.ToString();
            Amount = payPalTransaction.Amount;
            Status = ConvertStatus(payPalTransaction.Status);
        }

        public string TrackNumber { get; private set; }

        public decimal Amount { get; private set; }

        public string Status { get; private set; }

        public string ConvertStatus(string status)
        {
            switch (status)
            {
                case "P":
                    return "waiting_payment";
                case "S":
                    return "paid";
                case "F":
                    return "refunded";
                default:
                    return string.Empty;
            }
        }
    }
```
```csharp
        public StripeTransactionAdapter(StripeTransaction stripeTransaction)
        {
            TrackNumber = stripeTransaction.Code;
            Amount = stripeTransaction.GrossAmount;
            Status = ConvertStatus(stripeTransaction.Situation);
        }

        public string TrackNumber { get; private set; }

        public decimal Amount { get; private set; }

        public string Status { get; private set; }

        public string ConvertStatus(int status)
        {
            switch (status)
            {
                case 1:
                    return "waiting_payment";
                case 2:
                    return "paid";
                case 3:
                    return "cancelled";
                default:
                    return string.Empty;
            }
        }
```
- Adicionar a refer√™ncia da classe que voc√™ precisar adaptar na sua classe adaptadora. √â comum usar o construtor, mas voc√™ pode chamar quando chamar o m√©todo das suas classes.

```csharp
        [Test]
        public void ShouldBeAbleToCreateTransactionFromStripe()
        {
            var stripeTransaction = new StripeTransaction("AHN765NHD89", 1000, 2);
            var transaction = new StripeTransactionAdapter(stripeTransaction);

            using (new AssertionScope())
            {
                transaction.TrackNumber.Should().Be("AHN765NHD89");
                transaction.Amount.Should().Be(1000);
                transaction.Status.Should().Be("paid");
            }
        }

        [Test]
        public void ShouldBeAbleToCreateTransactionFromPaypal()
        {
            var payPalTransaction = new PaypalTransaction(7897897, 1000, "S");
            var transaction = new PayPalTransactionAdapter(payPalTransaction);

            using (new AssertionScope())
            {
                transaction.TrackNumber.Should().Be("7897897");
                transaction.Amount.Should().Be(1000);
                transaction.Status.Should().Be("paid");
            }
        }
```
---

### Decorator ou Wrapper ###
- O Decorator √© um padr√£o de projeto estrutural que permite que voc√™ adicione novos comportamentos a um objeto ao envolv√™-lo num wrapper que cont√©m os comportamentos.
- Dinamicamente agrega funcionalidades adicionais ao objeto. Fornece uma alternativa flex√≠vel ao uso de subclasses.
- O Decorator √© estruturado com base na **agrega√ß√£o** e **composi√ß√£o**. Essa abordagem permite que um objeto possa usar o comportamento de v√°rias classes, ter refer√™ncia a m√∫ltiplos objetos e delegue qualquer trabalho a eles.
- Utilize o padr√£o quando voc√™ precisa adicionar comportamentos para objetos em tempo de execu√ß√£o sem quebrar o c√≥digo que usa esses objetos.
- Utilize o padr√£o quando √© complicado ou imposs√≠vel usar heran√ßa para estender um comportamento.

**Exemplos**:
- Biblioteca de notifica√ß√£o que precisa enviar a mesma notifica√ß√£o por m√∫ltiplos canais (SMS, E-mail, Instagram, Facebook). Nesse caso, tem uma classe Notificador com m√©todo enviar e as demais classes SMS, E-mail, Instagram e Facebook s√£o decorators.
- Para conseguir customizar logs da aplica√ß√£o. 

**PROS**
- Pode estender o comportamento de um objeto sem fazer uma nova subclasse.
- Adicionar ou remover comportamentos de um objeto no momento da execu√ß√£o.
- Combinar comportamentos ao envolver o projeto com m√∫ltiplos decorators.
- Princ√≠pio da responsabilidade √∫nica: Pode dividir uma classe que implementa muitos comportamentos em classes menores. 

**CONS**
- √â dif√≠cil remover um wrapper de uma pilha de wrappers.
- √â dif√≠cil implementar um decorator que seu comportamento n√£o dependa da ordem da pilha de decorators. 

**Como implementar?**
- Descubra quais m√©todos s√£o comuns para o componente e para as camadas opcionais. Crie uma interface componente e declare os m√©todos.
- Crie uma classe componente concreta e defina o comportamento base nela.

```csharp
namespace DesignPatterns.Structural.Decorator
{
    public class Input
    {
        public string Cpf { get; set; }
        public IList<Item> Items { get; set; }
    }

    public class Item
    {
        public int Id { get; set; }
        public int Count { get; set; }
    }
}

namespace DesignPatterns.Structural.Decorator
{
    public interface IUseCase
    {
        public void Execute(Input input);
    }
}
namespace DesignPatterns.Structural.Decorator
{
    public class PlaceOrder : IUseCase
    {
        public void Execute(Input input)
        {
            Console.WriteLine($"Executando o place order {input}");
        }
    }
}
namespace DesignPatterns.Structural.Decorator
{
    public class SimulateFreight : IUseCase
    {
        public void Execute(Input input)
        {
            Console.WriteLine($"Executando o simulate freight: {input}");
        }
    }
}
namespace DesignPatterns.Structural.Decorator
{
    public class ValidateCoupon : IUseCase
    {
        public void Execute(Input input)
        {
            Console.WriteLine($"Executando o validate coupon {input}"); 
        }
    }
}
```

- Crie uma classe decorator base. Ela deve ter um campo para armazenar uma refer√™ncia ao objeto envolvido. O campo deve ser declarado com o tipo da interface componente para permitir uma liga√ß√£o entre os componentes concretos e decoradores. O decorador base deve delegar todo o trabalho para ao objeto envolvido.

```csharp
namespace DesignPatterns.Structural.Decorator
{
    public class LoggerUseCaseDecorator : IUseCase
    {
        private readonly IUseCase _useCase;

        public LoggerUseCaseDecorator(IUseCase useCase)
        {
            _useCase = useCase;    
        }

        public void Execute(Input input)
        {
            Console.WriteLine("Executando decorator de Log");
            _useCase.Execute(input);
        }
    }
}
```

- Crie decoradores concretos estendendo-os a partir do decorador base. Um decorador concreto deve executar seu comportamento antes ou depois da chamada para o m√©todo pai, que delega o comportamento para o objeto envolvido.

```csharp
using System.Diagnostics;

namespace DesignPatterns.Structural.Decorator
{
    public class PerformanceUseCaseDecorator : IUseCase
    {
        private readonly IUseCase _useCase;

        public PerformanceUseCaseDecorator(IUseCase useCase)
        {
            _useCase = useCase;
        }

        public void Execute(Input input)
        {
            var stopWatch = new Stopwatch();

            stopWatch.Start();
            _useCase.Execute(input);
            stopWatch.Stop();

            Console.WriteLine($"Performance: {stopWatch.Elapsed}");
        }
    }
}
```
- O cliente deve ser respons√°vel por criar decoradores e comp√¥-los da maneira desejada.

```csharp
using DesignPatterns.Structural.Decorator;

namespace DesignPatterns.Tests.Decorator
{
    public class DecoratorTests
    {
        [Test]
        public void ShouldBeAbleToLogOperationsInAUseCase()
        {
            var input = new Input
            {
                Cpf = "111111111",
                Items = new List<Item>
                {
                    new Item { Id = 1, Count = 1 },
                    new Item { Id = 2, Count = 1 },
                    new Item { Id = 3, Count = 3 },
                }
            };

            var placeOrder = new LoggerUseCaseDecorator(new PerformanceUseCaseDecorator(new PlaceOrder()));
            placeOrder.Execute(input);

            var simulateFreight = new LoggerUseCaseDecorator(new PerformanceUseCaseDecorator(new SimulateFreight()));
            simulateFreight.Execute(input);
        }
    }
}
```

### Proxy ###
- O Proxy √© um padr√£o de projeto estrutural que permite que voc√™ forne√ßa um substituto e controla o acesso ao objeto original, permitindo que voc√™ fa√ßa algo antes ou depois do pedido chegar no objeto original.
- Ao contr√°rio do Facade, o Proxy tem o mesma interface que seu objeto de servi√ßo.
- Ao contr√°rio do Decorator, que o ciclo de vida √© gerenciado pelo cliente, o Proxy geralmente gerencia o ciclo de vida de seu objeto servi√ßo.
- Utilize o padr√£o quando voc√™ precisa de uma inicializa√ß√£o pregui√ßosa, quando o objeto √© muito pesado e gasta muitos recursos do sistema por estar sempre rodando.
- Controle de acesso, o proxy pode passar o request somente se as credenciais coincidirem com os crit√©rios.
- Execu√ß√£o de um servi√ßo remoto (proxy remoto), nesse caso o proxy lida com toda a parte de redes.
- Execu√ß√£o de cache de resultado de pedidos.
- Refer√™ncia inteligente para analisar quando deve dispensar um objeto que utiliza recursos muito pesados, mas n√£o est√° sendo utilizado.

**Exemplos**:
- Um conversor que traduz json para xml e vice-versa antes de enviar para os objetos reais.
- Proxy de cache que armazena em cache resultados de consulta para evitar consumir a API real desnecessariamente.
- Proxy de seguran√ßa que controla o acesso com base nas permiss√µes antes de permitir consumir uma API. 

**PROS**
- Pode controlar o objeto do servi√ßo sem os clientes ficarem sabendo.
- Pode gerenciar o ciclo de vida de um objeto do servi√ßo, quando os clientes n√£o precisam mais dele.
- Pode trabalhar quando o objeto do servi√ßo n√£o est√° pronto ou indispon√≠vel.
- Princ√≠pio aberto e fechado: Pode introduzir novos proxies sem mudar o servi√ßo ou clientes.

**CONS**
- O c√≥digo pode ficar mais complexo, j√° que voc√™ precisa introduzir novas classes.
- Pode ter delay na resposta de um servi√ßo.

**Como implementar?**
- Crie uma interface o objeto proxy e o servi√ßo serem intercomunic√°veis. Quando n√£o for poss√≠vel fa√ßa proxy ser uma subclasse do servi√ßo.
- Crie a classe proxy que cont√©m um campo de refer√™ncia para o servi√ßo. Proxies costumam gerenciar todo o ciclo de vida, sendo em raras ocasi√µes, um servi√ßo passado ao proxy atr√°ves do construtor do cliente.
- Implemente os m√©todos proxy e ap√≥s a realiza√ß√£o do trabalho, delegue o trabalho para o objeto servi√ßo.

```csharp
namespace DesignPatterns.Structural.Proxy
{
    public class Customer
    {
        public Customer(string fullName, DateTime birthDate)
        {
            FullName = fullName;
            BirthDate = birthDate;
        }

        public string FullName { get; private set; }

        public DateTime BirthDate { get; private set; }
    }
}
using Microsoft.Extensions.Caching.Memory;

namespace DesignPatterns.Structural.Proxy
{
    public interface IMemoryCacheWrapper
    {
        object GetOrCreate(string key, Func<ICacheEntry, object> cacheFactory);
    }
}
using Microsoft.Extensions.Caching.Memory;

namespace DesignPatterns.Structural.Proxy
{
    public class MemoryCacheWrapper : IMemoryCacheWrapper
    {
        private readonly IMemoryCache _memoryCache;
        public MemoryCacheWrapper(IMemoryCache memoryCache)
        {
            _memoryCache = memoryCache;
        }
        public object GetOrCreate(string key, Func<ICacheEntry, object> cacheFactory)
        {
            return _memoryCache.GetOrCreate(key, cacheFactory)!;
        }
    }
}
namespace DesignPatterns.Structural.Proxy
{
    public class CustomerRepository
    {
        public virtual IList<Customer> GetBlockedUsers()
        {
            return new List<Customer>
            {
                new Customer("Fulano", DateTime.Now.AddYears(-20)),
                new Customer("Fulano", DateTime.Now.AddYears(-30)),
                new Customer("Fulano", DateTime.Now.AddYears(-40))
            };
        }
    }
}
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Caching.Memory;

namespace DesignPatterns.Structural.Proxy
{
    public class CustomerRepositoryProxy
    {
        private readonly CustomerRepository _customerRepository;
        private readonly IMemoryCacheWrapper _cache;
        private readonly IHttpContextAccessor _httpContextAccessor;

        public CustomerRepositoryProxy(
            CustomerRepository customerRepository,
            IMemoryCacheWrapper cache,
            IHttpContextAccessor httpContextAccessor)
        {
            _customerRepository = customerRepository;
            _cache = cache;
            _httpContextAccessor = httpContextAccessor;
        }

        public IList<Customer?> GetBlockedUsers()
        {
            var httpContext = _httpContextAccessor?.HttpContext;

            if(httpContext == null)
            {
                return null!;
            }

            if(httpContext.Request.Headers["x-role"] != "admin")
            {
                return null!;
            }

            var blockedCustomers = (IList<Customer?>)_cache.GetOrCreate("blocked-customers", c =>
            {
                return _customerRepository.GetBlockedUsers();
            });

            return blockedCustomers!;
        }
    }
}
```


### Flyweight ###
- Flyweight √© um padr√£o de projeto estrutural que permite otimizar o uso de objetos alocados na mem√≥ria RAM, compartilhando estados comuns entre os objetos, ao inv√©s de criar um para cada objeto.
- Utilize o padr√£o Flyweight apenas quando seu programa deve suportar um grande n√∫meros de objetos que n√£o cabe na mem√≥ria RAM.
- Lembre-se de sempre separar os estados mut√°veis dos imut√°veis, o padr√£o deve ser aplicado para estados imut√°veis.

**Exemplos**:
- Renderiza√ß√£o de gr√°ficos e textos para reduzir o consumo de mem√≥ria, reaproveitando a forma ou a fonte em outros objetos.
- Gest√£o de estados de jogos para armazenar as partes imut√°veis dos objetos, como modelo 3D, textura em uma inst√¢ncia compartilhada.

**PROS**
- Pode economizar muita RAM, desde que o sistema tenha muitos objetos similares.

**CONS**
- Pode estar trocando RAM por ciclos de CPU quando parte dos dados de contexto precisa ser recalculado cada vez que √© chamado um m√©todo flyweight.
- O c√≥digo fica mais complexo, nem sempre √© f√°cil perceber porque existe uma separa√ß√£o dos estados.

**Como implementar?**
- Divida os campos de uma classe que vai se tornar um flyweight em duas partes:
    - estado intr√≠nseco: os campos que cont√©m dados imut√°veis e duplicados em muitos objetos.
    - estado extr√≠nseco: os campos que cont√©m dados √∫nicos para cada objeto.
- Deixe os campos imut√°veis dentro da classe, certifique-se de que eles n√£o s√£o mut√°veis. Eles s√≥ podem obter valor inicial por meio do construtor.
- Para os m√©todos que usam campos para obter os dados mut√°veis introduza um novo par√¢metro e use-o ao inv√©s do campo.
- Opcionalmente pode-se criar uma factory para gerenciar o conjunto de flyweights e checar-se se j√° existe antes de criar um novo. Os clientes devem pedir flyweights a partir da f√°brica.
- O cliente deve armazenar ou calcular valores para o estado extr√≠nseco (contexto) para ser capaz de chamar m√©todos do objetos flyweight.


## Behavioral

### Chain of Responsability ###
- Cadeia de responsabilidade √© um design pattern comportamental que permite que passem as requisi√ß√µes adiante, como uma cadeia. E cada requisi√ß√£o/handle decide o que vai ser feito na cadeia.
- Especialmente √∫til quando tem que executar passos em sequ√™ncia.
- Os handlers s√£o conectados a uma cadeia e cada conex√£o do handler tem um campo que guarda a refer√™ncia para o pr√≥ximo handler.
Exemplos:
- Quando voc√™ quer ofertar um cart√£o de cr√©dito, mas precisa executar diversas valida√ß√µes antes para saber se a pessoa √© eleg√≠vel.
- Quando voc√™ precisa verificar se os usu√°rios est√£o autenticados e autorizados para acessar o sistema. Ent√£o, voc√™ pode usar cadeia de responsabilidade, quando o request √© criado e executado em sequ√™ncia o processo de autentica√ß√£o.

**PROS**
- Controlar a ordem de execu√ß√£o do request.
- Responsabilidade √∫nica: Desacople classes que invocam opera√ß√£o de classes que performam opera√ß√µes.
- Princ√≠pio do aberto fechado: Introduza novos handlers sem quebrar o c√≥digo cliente j√° existente.

**CONS**
- Risco de criar uma cadeia infinita.
- Depura√ß√£o pode ser mais dif√≠cil.
- A configura√ß√£o da cadeia pode ser complexa.

**Como implementar?**
- Declare a interface do handler e descreva a assinatura do seu m√©todo para lidar com as requisi√ß√µes do handler. Voc√™ pode converter as requisi√ß√µes em um objeto e passar no m√©todo do handler como um argumento.

```csharp
namespace DesignPatterns.Behavioral.Chain_of_Responsability_Adm
{
    public interface IHandler
    {
        void Handle(IList<Bill> bills, int amount);
    }
}
```

- Para eliminar c√≥digo duplicado em handlers concretos, voc√™ pode criar uma classe abstrata base, derivada da interface do handler. Essa classe cont√©m uma refer√™ncia ao **pr√≥ximo handler** na cadeia. Considere fazer essa classe imut√°vel, mas se voc√™ precisa modificar cadeias em tempo de execu√ß√£o, voc√™ precisa definir um setter para alterar o campo de refer√™ncia. Al√©m disso, voc√™ vai precisar criar um comportamento padr√£o para o m√©todo do handler, que √© passar o request para o pr√≥ximo objeto a menos que n√£o haja objeto. Handlers concretos poder√£o usar isso chamando o m√©todo pai.

```csharp
using static System.Runtime.InteropServices.JavaScript.JSType;

namespace DesignPatterns.Behavioral.Chain_of_Responsability_Adm
{
    public class BillHandler : IHandler
    {
        private readonly IHandler? _nextHandler;
        private readonly int _type;
       
        public BillHandler(IHandler? nextHandler, int type)
        {
            _nextHandler = nextHandler;
            _type = type;
        }

        public void Handle(IList<Bill> bills, int amount)
        {
            decimal notes = amount / _type;
            var count = (int)Math.Floor(notes);
            var bill = new Bill
            {
                Count = count,
                Type = _type,
            };

            bills.Add(bill);
            var remaining = amount % _type;

            if (_nextHandler != null)
            {
                _nextHandler.Handle(bills, remaining);
                return;
            }
            if (remaining > 0) throw new Exception("Without available notes!");
        }
    }
}
```

- Voc√™ pode criar suas pr√≥prias cadeias, receber cadeias pr√© constru√≠das de outros objetos ou implementar algumas classes factory para construir a cadeia.

```csharp
namespace DesignPatterns.Behavioral.Chain_of_Responsability_Adm
{
    public class Bill
    {
        public int Type { get; set; }
        public int Count { get; set; }
    }
}

namespace DesignPatterns.Behavioral.Chain_of_Responsability_Adm
{
    public class Atm
    {
        private readonly IHandler _handler;

        public Atm(IHandler handler)
        {
            _handler = handler;
        }

        public IList<Bill> Withdraw(int amount)
        {
            var bills = new List<Bill>();
            _handler.Handle(bills, amount);
            return bills;
        }
    }
}
```
- Clientes devem estar preparados para os seguintes cen√°rios: a cadeia consiste de um √∫nico link, aguns request n√£o devem seguir ao fim da cadeia e outras podem chegar ao fim da cadeia sem tratamento.

```csharp
using DesignPatterns.Behavioral.Chain_of_Responsability_Adm;
using FluentAssertions;

namespace DesignPatterns.Tests.Chain_of_Responsability
{
    public class AtmTests
    {
        [Test]
        public void ShouldBeAbleToRetrieveMoneyWithAllNotes()
        {
            var handler1 = new BillHandler(null, 1);
            var handler2 = new BillHandler(handler1, 2);
            var handler5 = new BillHandler(handler2, 5);
            var handler10 = new BillHandler(handler5, 10);
            var handler20 = new BillHandler(handler10, 20);
            var handler50 = new BillHandler(handler20, 50);
            var handler100 = new BillHandler(handler50, 100);
            var atm = new Atm(handler100);

            var bills = atm.Withdraw(978);

            var expectedBills = new List<Bill>
            {
                { new Bill { Count = 9, Type = 100 } },
                { new Bill { Count = 1, Type = 50 } },
                { new Bill { Count = 1, Type = 20 } },
                { new Bill { Count = 0, Type = 10 } },
                { new Bill { Count = 1, Type = 5 } },
                { new Bill { Count = 1, Type = 2 } },
                { new Bill { Count = 1, Type = 1 } },
            };

            bills.Should().BeEquivalentTo(expectedBills);
        }

        [Test]
        public void ShouldBeAbleToRetrieveMoneyWithOnlyOneNotes()
        {
            var handler1 = new BillHandler(null, 1);
            var atm = new Atm(handler1);

            var bills = atm.Withdraw(978);

            var expectedBills = new List<Bill>
            {
                { new Bill { Count = 978, Type = 1 } },
            };

            bills.Should().BeEquivalentTo(expectedBills);
        }

        [Test]
        public void ShouldBeAbleToRetrieveMoneyWithOnlyFiveAndTenNotes()
        {
            var handler5 = new BillHandler(null, 5);
            var handler10 = new BillHandler(handler5, 10);

            var atm = new Atm(handler10);
            var bills = atm.Withdraw(500);

            var expectedBills = new List<Bill>
            {
                { new Bill { Count = 50, Type = 10 } },
                { new Bill { Count = 0, Type = 5 } },
            };

            bills.Should().BeEquivalentTo(expectedBills);
        }
    }
}
```

### Visitor ###
- Visitor √© uma padr√£o de projeto comportamental que executa uma opera√ß√£o em uma lista de objetos diferentes da mesma classe m√£e.
- √â usado quando voc√™ tem diferentes objetos dentro de uma lista ou √°rvore.
- Visitor permite que voc√™ separe o comportamento/l√≥gica do objeto em que ele opera.

**PROS**
- Princ√≠pio do aberto fechado: porque voc√™ pode introduzir novos comportamentos para objetos espec√≠ficos sem mudar a classe pai.
- Princ√≠pio da responsabilidade √∫nica: porque voc√™ pode separar comportamento com sua classe respectiva.
- Visitor pode acumular informa√ß√µes e ser muito √∫til quando se trabalha com n√≥s de √°rvore.

**CONS**
- Voc√™ precisa atualizar todos os visitors quando uma classe √© modificada na hierarquia.
- Visitors podem n√£o ter os acessos necess√°rios para campos privados ou m√©todos.

**Como implementar?**
- Declare uma interface visitor com m√©todos visits, uma para elemento concreto da classe.

```csharp
namespace DesignPatterns.Behavioral.Visitor_Marketing
{
    public interface INotificationVisitor
    {
        string Visit(SmsMessage message);

        string Visit(EmailMessage message);
    }
}
```

- Declare uma classe abstrata ou uma interface com os m√©todos Accept que ir√£o receber objetos visitors como argumento.

```csharp
namespace DesignPatterns.Behavioral.Visitor_Marketing
{
    public interface IMarketingMessage
    {
        string From { get; }

        string To { get; }

        string Content { get; }

        string Accept(INotificationVisitor visitor);
    }
}
```

- Implemente os m√©todos Accept em todas as classes concretas. Esses m√©todos ir√£o redirecionar cada chamada do objeto visitor como um argumento.

```csharp
namespace DesignPatterns.Behavioral.Visitor_Marketing
{
    public class EmailMessage : IMarketingMessage
    {
        public EmailMessage(string from, string to, string subject, string content)
        {
            From = from;
            To = to;
            Subject = subject;
            Content = content;
        }

        public string From { get; private set; }

        public string To { get; private set; }

        public string Subject { get; private set; }

        public string Content { get; private set; }

        public string Accept(INotificationVisitor visitor)
        {
            return visitor.Visit(this);
        }
    }
}

namespace DesignPatterns.Behavioral.Visitor_Marketing
{
    public class SmsMessage : IMarketingMessage
    {
        public SmsMessage(string from, string to, string content)
        {
            From = from;
            To = to;
            Content = content;
        }

        public string From { get; private set; }

        public string To { get; private set; }

        public string Content { get; private set; }

        public string Accept(INotificationVisitor visitor)
        {
            return visitor.Visit(this);
        }
    }
}
```

- As classes de elementos somente trabalham com o visitor via interface do visitor. Visitors devem saber de todas os elementos concretos da classe como tipos de par√¢metro.
- Para cada comportamento na lista ou √°rvore, voc√™ tem que criar uma classe concreta do visitor e implementar os m√©todos visits.

```csharp
namespace DesignPatterns.Behavioral.Visitor_Marketing
{
    public class NotificationVisitor : INotificationVisitor
    {
        public string Visit(SmsMessage message)
        {
            return $"SMS message: From: {message.From}, To: {message.To}, Content: {message.Content}";
        }

        public string Visit(EmailMessage message)
        {
            return $"Email message: From: {message.From}, Subject: {message.Subject}, To: {message.To}, Content: {message.Content}";
        }
    }
}
namespace DesignPatterns.Behavioral.Visitor_Marketing
{
    public class NotificationService
    {
        private readonly INotificationVisitor _notificationVisitor;

        public NotificationService(INotificationVisitor notificationVisitor)
        {
            _notificationVisitor = notificationVisitor;
        }

        public IEnumerable<string> Notify(IList<IMarketingMessage> messages)
        {
            var visitor = _notificationVisitor;

            foreach (var message in messages)
            {
                yield return message.Accept(visitor);
            }
        }
    }
}
```
- O cliente deve criar objetos visitors e pass√°-los para elementos por meio de m√©todos de aceita√ß√£o.

```csharp
using DesignPatterns.Behavioral.Visitor_Marketing;
using FluentAssertions;
using FluentAssertions.Execution;

namespace DesignPatterns.Tests.Visitor
{
    public class NotificationServiceTests
    {
        [Test]
        public void ShouldBeAbleToCreateEmailMessageNotification()
        {
            var emailMessages = new List<IMarketingMessage>
            {
                new EmailMessage("Rafa", "T", "BFF", "We need to go out sometime!"),
            };

            var notificationVisitor = new NotificationVisitor();
            var notificationService = new NotificationService(notificationVisitor);
            var notifications = notificationService.Notify(emailMessages).ToList();

            var expectedEmailMessage = "Email message: From: Rafa, Subject: BFF, To: T, Content: We need to go out sometime!";
            using (new AssertionScope())
            {
                notifications.Should().BeEquivalentTo(expectedEmailMessage);
            }
        }

        [Test]
        public void ShouldBeAbleToCreateSMSMessageNotification()
        {
            var smsMessages = new List<IMarketingMessage>
            {
                new SmsMessage("T", "Rafa", "Definitely, we need to schedule!"),
            };

            var notificationVisitor = new NotificationVisitor();
            var notificationService = new NotificationService(notificationVisitor);
            var notifications = notificationService.Notify(smsMessages).ToList();

            var expectedSmsMessage = "SMS message: From: T, To: Rafa, Content: Definitely, we need to schedule!";
            using (new AssertionScope())
            {
                notifications.Should().BeEquivalentTo(expectedSmsMessage);
            }
        }

        [Test]
        public void ShouldBeAbleToCreateEmailAndSmsMessagesNotifications()
        {
            var emailMessage = new EmailMessage("Rafa", "T", "BFF", "We need to go out sometime!");
            var smsMessage = new SmsMessage("T", "Rafa", "Definitely, we need to schedule!");

            var messages = new List<IMarketingMessage>
            {
                emailMessage,
                smsMessage
            };

            var notificationVisitor = new NotificationVisitor();
            var notificationService = new NotificationService(notificationVisitor);
            var notifications = notificationService.Notify(messages).ToList();

            var expectedMessages = new List<string>
            {
                { "Email message: From: Rafa, Subject: BFF, To: T, Content: We need to go out sometime!" },
                { "SMS message: From: T, To: Rafa, Content: Definitely, we need to schedule!" },
            };

            using (new AssertionScope())
            {
                notifications.Should().Contain(expectedMessages);
            }
        }
    }
}
```

### Strategy ###
- O Strategy √© um padr√£o de projeto comportamental que permite selecionar um comportamento ou algoritmo em tempo de execu√ß√£o. O Strategy permite que o comportamento varie independentemente dos clientes que o utilizam, ou seja, torna-o intercambi√°vel.
- Use o padr√£o quando voc√™ quer usar usar diferentes variantes de um algoritmo dentro de um objeto e quer trocar de um algoritmo para o outro em tempo de execu√ß√£o.
- Quando tem classes parecidas que s√≥ diferem na forma que eles executam o comportamento.
- Use o padr√£o quando voc√™ tem um operador condicional muito grande que troca diferentes algoritmos dentro da mesma classe.

**Exemplos**
- C√°lculo de impostos com base numa faixa salarial.
- Um estacionamento em que o pre√ßo varia conforme o local (Praia, Shopping e Aeroporto, por exemplo).

**PROS**
- Princ√≠pio do aberto fechado: porque voc√™ pode introduzir novos comportamentos e algoritmos sem mudar o contexto.
- √â poss√≠vel trocar o algoritmo/comportamento usados dentro de um objeto durante a execu√ß√£o.
- Substitui heran√ßa por composi√ß√£o.
- √â poss√≠vel desacoplar os detalhes de implementa√ß√£o do algoritimo do c√≥digo cliente que usa ele.

**CONS**
- Se n√£o h√° muita variabilidade de algoritmos e eles raramente mudam, ent√£o n√£o h√° motivo para usar o padr√£o, pois s√≥ vai tornar o programa mais complexo.
- Os clientes devem estar cientes das diferen√ßas entre as estrat√©gias para selecionar a adequada.

**Como implementar?**
- Encontre o algoritmo que varia bastante ou a condicional na classe contexto. A classe contexto mant√©m uma refer√™ncia para uma das estrat√©gias concretas e se comunica com esse objeto atr√°ves da interface.
- O contexto chama o m√©todo de execu√ß√£o no objeto estrat√©gia. Ele n√£o sabe qual tipo de estrat√©gia est√° rodando ou como o algoritmo est√° sendo executado.

```csharp
namespace DesignPatterns.Behavioral.Strategy_Parking
{
    public class ParkingLot
    {
        private readonly IList<Ticket> _tickets;
        private readonly ITicketCalculator _ticketCalculator;
        private readonly int _totalLots;

        public ParkingLot(string location, int totalLots)
        {
            _tickets = new List<Ticket>();
            _ticketCalculator = TicketCalculatorFactory.Create(location);
            _totalLots = totalLots;
        }

        public void CheckIn(Ticket ticket)
        {
            _tickets.Add(ticket);
        }

        public void CheckOut(string plate, DateTime checkoutDate)
        {
            var ticket = GetTicket(plate);
            var period = new Period(ticket.CheckInDate, checkoutDate);
            ticket.Price = _ticketCalculator.Calculate(period);
        }

        public Ticket GetTicket(string plate)
        {
            var ticket = _tickets.FirstOrDefault(ticket => ticket.Plate == plate);

            if (ticket == null)
            {
                throw new Exception("Ticket not found!");
            }
            return ticket;
        }

        public int GetSlots()
        {
            return _totalLots - _tickets.Count;
        }
    }
}
```
- Declare a interface de estrat√©gia comum a todos os algoritmos.

```csharp
namespace DesignPatterns.Behavioral.Strategy_Parking
{
    public interface ITicketCalculator
    {
        long Calculate(Period period);
    }
}
```
- Extraia todos os algoritmos para suas pr√≥prias classes. Elas devem implementar a classe estrat√©gia.

```csharp
namespace DesignPatterns.Behavioral.Strategy_Parking
{
    public class AiportCalculator : ITicketCalculator
    {
        private const int DAILY_RATE = 50;

        public long Calculate(Period period)
        {
            return DAILY_RATE * period.GetDiffInDays();
        }
    }
}
namespace DesignPatterns.Behavioral.Strategy_Parking
{
    public class BeachCalculator : ITicketCalculator
    {
        private const int HOURLY_RATE = 5;

        public long Calculate(Period period)
        {
            return HOURLY_RATE * period.GetDiffInHours();
        }
    }
}
namespace DesignPatterns.Behavioral.Strategy_Parking
{
    public class ShoppingCalculator : ITicketCalculator
    {
        private const long BASE_RATE = 10;
        private const int BASE_PERIOD = 3;
        private const int HOURLY_RATE = 3;

        public long Calculate(Period period)
        {
            var price = BASE_RATE;
            var remainingHours = period.GetDiffInHours() - BASE_PERIOD;

            if(remainingHours > 0)
            {
                price += remainingHours * HOURLY_RATE;
            }

            return price;
        }
    }
}
namespace DesignPatterns.Behavioral.Strategy_Parking
{
    public class Ticket
    {
        public string Plate { get; set; } = null!;
        public DateTime CheckInDate { get; set; }
        public decimal? Price { get; set; }
    }
}
namespace DesignPatterns.Behavioral.Strategy_Parking
{
    public class TicketCalculatorFactory
    {
        private static IDictionary<string, ITicketCalculator> calculators = new Dictionary<string, ITicketCalculator>()
        {
            {
                "beach", new BeachCalculator()
            },
            {
                "shopping", new ShoppingCalculator()
            },
            {
                "airport", new AiportCalculator()
            }
        };

        public static ITicketCalculator Create(string location)
        {
            if(!calculators.TryGetValue(location, out var findCalculator))
            {
                throw new Exception("Ticket calculator not found!");
            }

            return findCalculator;
        }
    }
}
```
- O cliente identifica qual estrat√©gia ele quer chamar e chama pelo contexto.

```csharp
using DesignPatterns.Behavioral.Strategy_Parking;
using FluentAssertions;

namespace DesignPatterns.Tests.Strategy
{
    public class ParkingLotTests
    {
        [Test]
        public void ShouldBeAbleToCreateAParkingLot()
        {
            var parkingLot = new ParkingLot("airport", 500);
            parkingLot.GetSlots().Should().Be(500);
        }

        [Test]
        public void ShouldBeAbleToParkTheCarOnTheBeachForTwoHoursAndWhenLeavingTheValueShouldBeTen_FiveByHour()
        {
            var parkingLot = new ParkingLot("beach", 500);
            var ticketDto = new Ticket
            {
                CheckInDate = new DateTime(2021, 10, 01, 10, 00, 00),
                Plate = "AAA-1111",
            };
            
            parkingLot.CheckIn(ticketDto);
            parkingLot.CheckOut("AAA-1111", new DateTime(2021, 10, 01, 12, 00, 00));

            var ticket = parkingLot.GetTicket("AAA-1111");
            ticket.Price.Should().Be(10);
        }

        [Test]
        public void ShouldBeAbleToParkTheCarInTheShoppingForSevenHoursAndWhenLeavingTheValueShouldBeTwentyTwoTenTheFirstThreeHoursAndAfterThreeForHour()
        {
            var parkingLot = new ParkingLot("shopping", 500);
            var ticketDto = new Ticket
            {
                CheckInDate = new DateTime(2021, 10, 01, 10, 00, 00),
                Plate = "AAA-1111",
            };

            parkingLot.CheckIn(ticketDto);
            parkingLot.CheckOut("AAA-1111", new DateTime(2021, 10, 01, 17, 00, 00));

            var ticket = parkingLot.GetTicket("AAA-1111");
            ticket.Price.Should().Be(22);        
        }

        [Test]
        public void ShouldBeAbleToParkInTheAirportForThreeDaysAndWhenLeavingTheValueShouldBeOneHundredAndFiftyForDay()
        {
            var parkingLot = new ParkingLot("airport", 500);
            var ticketDto = new Ticket
            {
                CheckInDate = new DateTime(2021, 10, 01, 10, 00, 00),
                Plate = "AAA-1111",
            };

            parkingLot.CheckIn(ticketDto);
            parkingLot.CheckOut("AAA-1111", new DateTime(2021, 10, 04, 10, 00, 00));

            var ticket = parkingLot.GetTicket("AAA-1111");
            ticket.Price.Should().Be(150);
        }
    }
}
```

### Template Method ###
- √â um padr√£o de projeto comportamental que permite que subclasses redefinam passos espec√≠ficos de um algoritmo sem mudar a ordem e estrutura em que esses passos s√£o executados.
- Geralmente usado quando as subclasses tem c√≥digos muito semelhantes (quando existe um padr√£o).
- Utilize template method quando voc√™ quiser que o cliente estenda apenas etapas espec√≠ficas de uma classe.
- Utilize quando voc√™ tem classes quase id√™nticas com pequenas diferen√ßas.

**Exemplos**
- Prepara√ß√£o de uma bebida em que voc√™ tem uma ordem de prepara√ß√£o e ingredientes comuns e espec√≠ficos.
- Um item que tem c√°lculos de impostos e tem as subclasses Whisky, Beer e Water, mas Water n√£o tem imposto.

**PROS**
- O cliente pode sobrescrever apenas partes de um algoritmo grande.
- Pode reduzir c√≥digo duplicado para uma superclasse.

**CONS**
- Pode violar o Princ√≠pio de substitui√ß√£o de Liskov ao suprimir uma etapa padr√£o de implementa√ß√£o atr√°ves de subclasse.
- Implementa√ß√µes do Template Method tendem a ser mais dif√≠ceis de se manter quanto mais etapas eles tiverem.

**Como implementar?**
- Defina a classe abstrata e declare o m√©todo que servir√° como templateMethod.

```csharp
public abstract class Item
{
    public Item(string category, string description, decimal price)
    {
        Category = category;
        Description = description;
        Price = price;
    }

    public string Category { get; private set; }
    public string Description { get; private set; }
    public decimal Price { get; private set; }
}

public abstract class TaxItem : Item
{
    protected TaxItem(string category, string description, decimal price) 
        : base(category, description, price)
    {
    }

    public decimal CalculateTax()
    {
        return (Price * GetTaxRate()) / 100;
    }

    public abstract decimal GetTaxRate();
}
```

- Defina as subclasses concretas.

```csharp
public class Beer : TaxItem
{
    public Beer(string description, decimal price) 
        : base("Beer", description, price)
    {
    }

    public override decimal GetTaxRate()
    {
        return 10;
    }
}

public class Whisky : TaxItem
{
    public Whisky(string description, decimal price) 
        : base("Whisky", description, price)
    {
    }

    public override decimal GetTaxRate()
    {
        return 20;
    }
}

public class Water : Item
{
    public Water(string description, decimal price) 
        : base("Water", description, price)
    {
    }
}
```

- Defina as classes que ir√° chamar as classes abstratas e o cliente que ir√° utilizar

```csharp
public class Invoice
{
    private readonly IList<Item> _items;

    public Invoice()
    {
        _items = new List<Item>();
    }

    public void Add(Item item)
    {
        _items.Add(item);
    }

    public decimal GetTaxes()
    {
        return _items.Where(item => item is TaxItem)
                     .Cast<TaxItem>()
                     .Sum(taxItem => taxItem.CalculateTax());
    }
}

using DesignPatterns.Behavioral.TemplateMethod_Beverage;
using FluentAssertions;

namespace DesignPatterns.Tests.Template_Method
{
    public class TempleateMethodBeverageTests
    {
        [Test]
        public void ShouldBeAbleToCalculateTaxesOfInvoice()
        {
            var invoice = new Invoice();
            invoice.Add(new Beer("Heineken", 20));
            invoice.Add(new Whisky("Jack Daniels", 100));
            invoice.Add(new Water("Crystal", 5));

            var taxes = invoice.GetTaxes();

            taxes.Should().Be(22);
        }
    }
}
```

### Mediator ###
- O Mediator √© um padr√£o de projeto comportamental que restringe comunica√ß√µes diretas entre objetos e os for√ßa se comunicar por meio de um objeto mediador.
- Define um objeto que encapsula a forma como um conjunto de objetos interage.
- √â como se fosse um motor de controle. √â um tipo de padr√£o de desacoplamento.
- Utilize o padr√£o Mediator quando √© dif√≠cil mudar algumas classes porque elas est√£o acopladas a outras.
- Utilize o padr√£o quando n√£o puder reutilizar um componente porque ele √© dependente de outros componentes.
- Utilize o padr√£o quando voc√™ criar muitas subclasses para componentes apenas para reusar algum comportamento b√°sico em v√°rios contextos.
- Rela√ß√£o com eventos, mensageria.
- Muitos para muitos.

**Exemplos**
- Um chat √© um bom exemplo de Mediator, pois facilita a comunica√ß√£o entre v√°rios usu√°rios, grupos de usu√°rios e funcionalidades adicionais.
- Um formul√°rio de inscri√ß√£o que voc√™ escolhe uma op√ß√£o em um menu que pode habilitar ou desabilitar campos com base nas intera√ß√µes do usu√°rio, o mediador pode centralizar essa l√≥gica de habilitar ou desabilitar campos.
- Um painel de controle, onde diferentes widgets precisam interagir entre si. Por exemplo, ao atualizar um gr√°fico, a atualiza√ß√£o pode refletir em um painel de resumo de estat√≠stica.

**PROS**
- Promove o desacoplamento ao evitar que os objetos se refiram uns aos outros explicitamente, permitindo variar suas intera√ß√µes independentemente.
- Princ√≠pio da responsabilidade √∫nica, pois voc√™ pode extrair as comunica√ß√µes entre v√°rios componentes para um √∫nico lugar.
- Princ√≠pio aberto/fechado voc√™ pode introduzir novos mediadores sem ter que modificar o componente.
- Voc√™ pode reutilizar componentes individuais mais facilmente.

**CONS**
- O objeto mediador pode se tornar um objeto Deus, ou seja, um objeto que sabe demais ou que faz demais.

**Como implementar?**
- Identifique classes que est√£o acopladas e que poderiam ser beneficiadas se estiverem mais independentes.
- Declare a interface do mediador e o m√©todo que vai receber as notifica√ß√µes.
- Implemente a classe concreta do mediador. A classe fica respons√°vel por armazenar todas as refer√™ncias que ela gerencia.
- Componentes devem armazenar uma refer√™ncia ao objeto do mediador, geralmente no construtor passando o mediador por argumento.

```csharp
namespace DesignPatterns.Behavioral.Mediator_Channel
{
    public class Channel
    {
        private readonly IList<Participant> _participants;

        public Channel()
        {
            _participants = new List<Participant>();
        }

        public void Register(Participant participant)
        {
            _participants.Add(participant);
        }

        public void SendAll(Participant from, string message)
        {
            foreach(var to in _participants)
            {
                if (from != to)
                {
                    to.Receive(from, message);
                }
            }
        }
    }
}
```
- Mude as classes para chamar o objeto mediador ao inv√©s dos outros componentes diretamente.

```csharp
using DesignPatterns.Behavioral.Mediator_Channel;

namespace DesignPatterns.Tests.Mediator
{
    public class ChatTests
    {
        [Test]
        public void ShouldBeAbleToExchangeMessagesBetweenTheChannel()
        {
            var firstParticipant = new Participant("FirstParticipant");
            var secondParticipant = new Participant("SecondParticipant");
            var thirdParcipant = new Participant("ThirdParticipant");

            var channel = new Channel();
            channel.Register(firstParticipant);
            channel.Register(secondParticipant);
            channel.Register(thirdParcipant);

            channel.SendAll(firstParticipant, "Hello!");
        }
    }
}

```

### Command ###
- O Command √© um padr√£o de projeto comportamental que encapsula uma solicita√ß√£o como um objeto.
- Desacopla quem chama de quem √© chamado.
- Vem com o objetivo de separar leitura da escrita. 
- Permite que cliente diferentes parametrizem comandos de forma diferente.
- Enfileira ou faz registros de solicita√ß√µes.
- Suporta opera√ß√µes que podem ser desfeitas.
- O retorno de um Command √© sempre void, pelo motivo de que voc√™ desacopla quem chama de quem √© chamado (n√£o tem quem espere a resposta).
- Utilize o padr√£o quando voc√™ quer colocar opera√ß√µes em fila, agendar sua execu√ß√£o ou execut√°-las ap√≥s um tempo.
- Utilize o padr√£o Command quando voc√™ quer implementar opera√ß√µes revers√≠veis.

**Exemplos**
- Os d√©bitos e cr√©ditos de uma conta, pois √© importante ter todo o hist√≥rico e conseguir desfazer ou refazer uma opera√ß√£o.
- Editor de texto.
- Cen√°rios em que voc√™ deseja separar leitura de escrita.

**PROS**
- Princ√≠pio da responsabilidade √∫nica: √â poss√≠vel desacoplar classes que invocam opera√ß√µes de classes que fazem opera√ß√µes.
- Princ√≠pio do aberto e fechado: √â poss√≠vel introduzir novos comandos sem quebrar o c√≥digo j√° existente.
- Voc√™ pode implementar desfazer/refazer.
- Voc√™ pode implementar a execu√ß√£o adiada de opera√ß√µes.
- Voc√™ pode montar um conjunto de comandos simples em um complexo. 

**CONS**
- O c√≥digo pode ficar mais complicado j√° que voc√™ est√° introduzindo uma nova camada entre remetentes e destinat√°rios.

**Como implementar?**
- Declare a interface de command com um √∫nico m√©todo de execu√ß√£o.

```csharp
namespace DesignPatterns.Behavioral.Command_Transaction
{
    public interface ICommand
    {
        void Execute();
    }
}
```

- Extraia os pedidos para dentro das classes concretas que implementam a classe command. Cada classe deve ter um conjunto de campos para armazenar os argumentos dos pedidos junto com a refer√™ncia ao objeto destinat√°rio real. Os valores devem ser inicializados no construtor do command.

```csharp
namespace DesignPatterns.Behavioral.Command_Transaction
{
    public class CreditCommand : ICommand
    {
        private readonly Account _account;      
        private readonly decimal _amount;

        public CreditCommand(Account account, decimal amount)
        {
            _account = account;
            _amount = amount;
        }

        public void Execute()
        {
            _account.Credit(_amount);
        }
    }
}
namespace DesignPatterns.Behavioral.Command_Transaction
{
    public class DebitCommand : ICommand
    {
        private readonly Account _account;
        private readonly decimal _amount;

        public DebitCommand(Account account, decimal amount)
        {
            _account = account;
            _amount = amount;
        }

        public void Execute()
        {
            _account.Debit(_amount);
        }
    }
}
```

- Identifique as classes que v√£o ser remetentes. Adicione os campos para armazenar commands nessa classe. Remetentes devem sempre se comunicar com seus comandos atr√°ves da interface command.
- Mude os remetentes para executar o command ao inv√©s de enviar o pedido para o destinat√°rio diretamente.

```csharp
namespace DesignPatterns.Behavioral.Command_Transaction
{
    public class Transaction
    {
        public Transaction(string type, decimal amount) 
        {
            Type = type;
            Amount = amount;
        }

        public string Type { get; private set; }

        public decimal Amount { get; private set; }
    }
}

namespace DesignPatterns.Behavioral.Command_Transaction
{
    public class Account
    {
        private readonly IList<Transaction> _transactions;

        public Account()
        {
            _transactions = new List<Transaction>();
        }

        public void Credit(decimal amount)
        {
            var transaction = new Transaction("credit", amount);
            _transactions.Add(transaction);
        }

        public void Debit(decimal amount)
        {
            var transaction = new Transaction("debit", amount);
            _transactions.Add(transaction);
        }

        public decimal GetBalance()
        {
            decimal balance = 0;
            foreach (var transaction in _transactions)
            {
                if(transaction.Type == "credit")
                {
                    balance += transaction.Amount;
                }

                if(transaction.Type == "debit")
                {
                    balance -= transaction.Amount;
                }
            }

            return balance;
        }
    }
}
```
- O cliente deve inicializar objetos criando os destinat√°rios, criando os commands e os associando com os destinat√°rios se necess√°rio, ou criando os remetentes e associando os commands espec√≠ficos.

```csharp
using DesignPatterns.Behavioral.Command_Transaction;
using FluentAssertions;

namespace DesignPatterns.Tests.Command
{
    public class AccountTests
    {
        [Test]
        public void ShouldBeAbleToCreateAnAccount()
        {
            var account = new Account();
            var balance = account.GetBalance();

            balance.Should().Be(0);
        }

        [Test]
        public void ShouldBeAbleToCreditFromAnAccountUsingCommand()
        {
            var account = new Account();
            var creditCommand = new CreditCommand(account, 100);
            
            creditCommand.Execute();

            var balance = account.GetBalance();
            balance.Should().Be(100);
        }

        [Test]
        public void ShouldBeAbleToDebitFromAnAccountUsingCommand()
        {
            var account = new Account();
            var creditCommand = new CreditCommand(account, 100);
            var debitCommand = new DebitCommand(account, 50);

            creditCommand.Execute();
            debitCommand.Execute();

            var balance = account.GetBalance();
            balance.Should().Be(50);
        }
    }
}
```

### Observer (Publish-Subscriber) ###
- O observer √© um padr√£o de projeto comportamental que permite que voc√™ defina uma forma de assinatura para que v√°rios objetos tenham ci√™ncia de quando um evento acontecer sobre o objeto que est√£o observando.
- Quando o objeto muda de estado, os seus dependentes s√£o notificados e atualizados.
- Utilize o padr√£o quando observer quando mudan√ßas no estado de um objeto podem precisar mudar outros objetos e o conjunto de objetos √© desconhecido ou muda dinamicamente.

**Exemplos**
- Para assinatura de um produto espec√≠fico (Ex: Um cliente que quer receber notifica√ß√£o sobre quando uma TV espec√≠fica estiver a venda ou em promo√ß√£o).
- Quando voc√™ quer executar alguma a√ß√£o em um componente ap√≥s um evento em outro componente acontecer (Ex: Mudar a label do Pa√≠s para Brasil quando o input receber esse valor). 

**PROS**
- Princ√≠pio aberto fechado: Voc√™ pode introduzir novas classes assinantes sem ter que modificar o c√≥digo da publicadora e vice-versa.
- Voc√™ pode estabelecer rela√ß√µes entre objetos durante a execu√ß√£o.

**CONS**
- Assinantes s√£o notificados em ordem aleat√≥ria.

**Como implementar?**
- Identifique a funcionalidade principal e defina-a como publicadora. As outras classes ser√£o as assinantes.
- Declare a interface do assinante com um m√©todo para notificar os assinantes.

```csharp
namespace DesignPatterns.Behavioral.Observer_UI
{
    public interface IObserver
    {
        void Notify(string name, string value);
    }
}
```

- Declare a interface da publicadora e descreva m√©todos para adicionar e remover um assinante da lista. As classes publicadoras s√≥ devem se comunicar com os assinantes por meio do assinante.
- Decida onde colocar a lista atual dos assinantes e a implementa√ß√£o do m√©todos para adi√ß√£o e remo√ß√£o de assinantes, o melhor lugar √© numa classe abstrata derivada da classe publicadora.

```csharp
namespace DesignPatterns.Behavioral.Observer_UI
{
    public abstract class Observable
    {
        public IList<IObserver> _observables;

        public Observable()
        {
            _observables = new List<IObserver>();
        }

        public void Subscribe(IObserver observer)
        {
            _observables.Add(observer);
        }

        public void NotifyAll(string name, string value)
        {
            foreach(var observer in _observables)
            {
                observer.Notify(name, value);
            }
        }
    }
}
```

- Crie as classes publicadoras concretas e a cada vez que algo acontece, ela deve notificar seus assinantes.

```csharp
namespace DesignPatterns.Behavioral.Observer_UI
{
    public class InputText : Observable
    {
        public InputText(string name)
            : base()
        {
            Value = "";
            Name = name;
        }

        public string Value { get; private set; }
        public string Name { get; private set; }

        public void SetValue(string value)
        {
            Value = value;
            NotifyAll(Name, Value);
        }
    }
}
```
- Crie as classes concretas dos assinantes.

```csharp
namespace DesignPatterns.Behavioral.Observer_UI
{
    public class Label : IObserver
    {
        private readonly string _expression;

        public Label(string expression)
        {
            _expression = expression;
            Value = "";
        }

        public string Value { get; private set; }

        public void Notify(string name, string value)
        {
            Value = _expression.Replace($"{name}", value);
        }
    }
}
```

- O cliente deve criar todos os assinantes necess√°rios e registr√°-los com suas publicadoras.

```csharp
using DesignPatterns.Behavioral.Observer_UI;
using FluentAssertions;
using FluentAssertions.Execution;

namespace DesignPatterns.Tests.Observer
{
    public class ComponentTests
    {
        [Test]
        public void ShouldBeAbleToWriteInTheInputAndShowUpdatedDataInTheLabel()
        {
            var inputText = new InputText("country"); //observable
            var firstCountryLabel = new Label($"Pa√≠s: {inputText.Name}"); //observer
            var secondCountryLabel = new Label($"Country: {inputText.Name}"); //observer

            inputText.Subscribe(firstCountryLabel);
            inputText.Subscribe(secondCountryLabel);
            inputText.SetValue("Brasil");

            using (new AssertionScope())
            {
                firstCountryLabel.Value.Should().Be("Pa√≠s: Brasil");
                secondCountryLabel.Value.Should().Be("Country: Brasil");
            }

            inputText.SetValue("Fran√ßa");

            using (new AssertionScope())
            {
                firstCountryLabel.Value.Should().Be("Pa√≠s: Fran√ßa");
                secondCountryLabel.Value.Should().Be("Country: Fran√ßa");
            }
        }
    }
}
```

### State ###
- O State √© um padr√£o de projeto comportamental que permite que um objeto altere seu comportamento com base num estado interno.
- Semelhante ao padr√£o Strategy, mas o State pode estar ciente de outro estado e transitar de um para o outro, enquanto o Strategy raramente sabe sobre as outras estrat√©gias.
- Utilize o padr√£o quando voc√™ tem um objeto que se comporta de maneira diferente dependendo do seu estado atual, quando o n√∫mero de estados √© enorme e quando o c√≥digo espec√≠fico muda com frequ√™ncia.
- Utilize o padr√£o quando voc√™ tem muitas condicionais grandes que alteram como a classe se comporta de acordo com os valores atuais.
- Utilize o padr√£o quando voc√™ tem muito c√≥digo duplicado em muitos estados parecidos e transi√ß√µes baseadas em condi√ß√µes.

**Exemplos**
-  Um documento que tenha tr√™s estados: rascunho, modera√ß√£o e publicado e cada um desses status √© respons√°vel por fazer algo diferenre no sistema.
- Um pedido que tem os status pendente, confirmado e cancelado e a partir de cada estado tem que ser feito uma a√ß√£o diferente.
- Um editor de texto que a partir de um sele√ß√£o, como por exemplo, negrito, muda a cor do texto para negrito.

**PROS**
- Princ√≠pio da responsabilidade √∫nica: Separa os estados em classes separadas.
- Princ√≠pio aberto e fechado: Introduz novos estados sem quebrar c√≥digo j√° existente.
- Evita o uso de condicionais muito grandes e complexas.

**CONS**
- A aplica√ß√£o pode ser over-engineer se a classe n√£o tiver muito estados ou se raramente os status mudam.

**Como implementar?**
- Decida qual classe vai agir como contexto. Pode ser uma classe existente que j√° tenha c√≥digo dependente do estado.
- Na classe contexto, adicione um campo de refer√™ncia do tipo interface do estado e um setter p√∫blico que permite sobrescrever o valor daquele campo.
- Para trocar o estado do contexto, crie uma inst√¢ncia de uma das classes de estado e passe para o contexto. Pode ser feito dentro do pr√≥prio contexto, ou em v√°rios estados, ou no cliente. Lembre-se que a classe se torna dependente da classe concretaa de estado que ela instanciou.

```csharp
namespace DesignPatterns.Behavioral.State
{
    public class Order
    {
        public Order()
        {
            Status = new PendingStatus(this);
        }

        public OrderStatus Status { get; set; }

        public void Confirm()
        {
            Status.Confirm();
        }

        public void Cancel()
        {
            Status.Cancel();
        }
    }
}
```
- Declare a interface do estado, colocando m√©todos que contenham comportamentos espec√≠fico ao estado.

```csharp
namespace DesignPatterns.Behavioral.State
{
    public abstract class OrderStatus
    {
        private readonly Order _order;

        public OrderStatus(Order order)
        {
            _order = order;
        }

        public abstract string Value { get; set; }

        public abstract void Confirm();

        public abstract void Cancel();
    }
}
```

- Para cada estado, crie uma classe concreta que deriva da interface do estado. Ent√£o, extraia todo o conte√∫do do contexto e coloque nessa classe.

```csharp
namespace DesignPatterns.Behavioral.State
{
    public class PendingStatus : OrderStatus
    {
        private readonly Order _order;

        public PendingStatus(Order order)
            : base(order)
        {
            _order = order;
            Value = "Pending";
        }

        public override string Value { get; set; } = null!;

        public override void Confirm()
        {
            _order.Status = new ConfirmedStatus(_order);
        }

        public override void Cancel()
        {
            _order.Status = new CancelledStatus(_order);
        }
    }
}

namespace DesignPatterns.Behavioral.State
{
    public class ConfirmedStatus : OrderStatus
    {
        private readonly Order _order;

        public ConfirmedStatus(Order order)
            : base(order)
        {
            Value = "Confirmed";
            _order = order;
        }

        public override string Value { get; set; } = null!;

        public override void Confirm()
        {
            throw new Exception("The order is already confirmed!");
        }
        
        public override void Cancel()
        {
            _order.Status = new CancelledStatus(_order);
        }
    }
}

namespace DesignPatterns.Behavioral.State
{
    public class CancelledStatus : OrderStatus
    {
        private readonly Order _order;

        public CancelledStatus(Order order)
            : base(order)
        {
            _order = order;
            Value = "Cancelled";
        }

        public override string Value { get; set; }

        public override void Confirm()
        {
            throw new Exception("The order is already cancelled!");
        }

        public override void Cancel()
        {
            throw new Exception("The order is already cancelled!");
        }
    }
}

using DesignPatterns.Behavioral.State;
using FluentAssertions;

namespace DesignPatterns.Tests.State
{
    public class OrderStatusTests
    {
        [Test]
        public void ShouldBeAbleToCreateAnPedingStatus()
        {
            var order = new Order();
            order.Status.Value.Should().Be("Pending");
        }

        [Test]
        public void ShouldBeAbleToChangeOrderStatusToConfirmed()
        {
            var order = new Order();
            order.Confirm();

            order.Status.Value.Should().Be("Confirmed");
        }

        [Test]
        public void ShouldBeAbleToChangeOrderStatusToCancelled()
        {
            var order = new Order();
            order.Cancel();

            order.Status.Value.Should().Be("Cancelled");
        }

        [Test]
        public void ShouldNotBeAbleToChangeOrderStatusToConfirmedIfTheOrderHasAlreadyBeenCancelled()
        {
            var order = new Order();
            order.Cancel();

            order.Invoking(o => o.Confirm())
                .Should().Throw<Exception>()
                .WithMessage("The order is already cancelled!");
        }
    }
}
```

## üß™ Techs

This project was develop with the following technologies:

- [.NET 7 Console Application](https://docs.microsoft.com/pt-br/dotnet/core/dotnet-7)

## How can I use?

You will need of the Visual Studio 2022 and .NET 7 SDK.
This SKDs and tools can be download in .NET 7 https://dot.net/core.
You can execute in Visual Studio Code too (Windows, Linux or MacOS)

## üöÄ How can I execute?

Clone the projet and access the pasta.

```bash
$ git clone https://github.com/rafaelaccampos/design-patterns-in-csharp
$ cd DesignPatterns

$ dotnet restore

```

To initiate the tests, follow the steps below:
```bash
$ dotnet test
```


