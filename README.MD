<h1 align="center">Design Patterns in C#</h1>

## üíª Project
Esse projeto tem como objetivo estudar Design Patterns implementados em C#. Ele cont√©m teoria e a implementa√ß√£o do c√≥digo.
This project has the goal to study design patterns implemented in C#. It's contain theory and code implementation.

## Structural

### Adapter ###
Adapter √© um padr√£o de projeto estrutural que permite que classes incompat√≠veis se comuniquem. Ele tamb√©m serve como uma camada anticorrup√ß√£o que permite desacoplamento.
Exemplos:
- Diferentes implementa√ß√µes de gateway que tem que se comunicar com seu dom√≠nio que tem diferentes interfaces.
- Quando voc√™ tem c√≥digo legado e precisa adaptar para classes modernas.

**PROS**
- Responsabilidade √∫nica: Separar diferentes dados das regras de neg√≥cio.
- Princ√≠pio do aberto fechado: Voc√™ consegue introduzir novos adaptadores sem quebrar os clientes existentes, contanto que o contrato da interface seja preservada.

**CONS**
- A complexidade do c√≥digo aumenta porque √© introduzido muitas novas interfaces e classes.

**Como implementa?**
- Cria uma interface que descreve o contrato que outras classes devem seguir.

```csharp
namespace DesignPatterns.Structural.Adapter.Adapter_Transaction
{
    public interface ITransaction
    {
        public string TrackNumber { get; }
        public decimal Amount { get; }
        public string Status { get; }
    }
}
```

- Criar as classes desejadas.

```
    public class PaypalTransaction
    {
        public PaypalTransaction(int id, int amount, string status)
        {
            Id = id;
            Amount = amount;
            Status = status;
        }

        public int Id { get; private set; }
        public decimal Amount { get; private set; }
        public string Status { get; private set; }
    }
```
```
    public class StripeTransaction
    {
        public StripeTransaction(string code, decimal grossAmount, int situation)
        {
            Code = code;
            GrossAmount = grossAmount;
            Situation = situation;
        }

        public string Code { get; private set; }
        public decimal GrossAmount { get; private set; }
        public int Situation { get; private set; }
    }
```
- Criar o adaptador para as classes desejadas que v√£o implementar a interface.

```
    public class PayPalTransactionAdapter : ITransaction
    {
        public PayPalTransactionAdapter(PaypalTransaction payPalTransaction)
        {
            TrackNumber = payPalTransaction.Id.ToString();
            Amount = payPalTransaction.Amount;
            Status = ConvertStatus(payPalTransaction.Status);
        }

        public string TrackNumber { get; private set; }

        public decimal Amount { get; private set; }

        public string Status { get; private set; }

        public string ConvertStatus(string status)
        {
            switch (status)
            {
                case "P":
                    return "waiting_payment";
                case "S":
                    return "paid";
                case "F":
                    return "refunded";
                default:
                    return string.Empty;
            }
        }
    }
```
```
        public StripeTransactionAdapter(StripeTransaction stripeTransaction)
        {
            TrackNumber = stripeTransaction.Code;
            Amount = stripeTransaction.GrossAmount;
            Status = ConvertStatus(stripeTransaction.Situation);
        }

        public string TrackNumber { get; private set; }

        public decimal Amount { get; private set; }

        public string Status { get; private set; }

        public string ConvertStatus(int status)
        {
            switch (status)
            {
                case 1:
                    return "waiting_payment";
                case 2:
                    return "paid";
                case 3:
                    return "cancelled";
                default:
                    return string.Empty;
            }
        }
```
- Adicionar a refer√™ncia da classe que voc√™ precisar adaptar na sua classe adaptadora. √â comum usar o construtor, mas voc√™ pode chamar quando chamar o m√©todo das suas classes.

```
        [Test]
        public void ShouldBeAbleToCreateTransactionFromStripe()
        {
            var stripeTransaction = new StripeTransaction("AHN765NHD89", 1000, 2);
            var transaction = new StripeTransactionAdapter(stripeTransaction);

            using (new AssertionScope())
            {
                transaction.TrackNumber.Should().Be("AHN765NHD89");
                transaction.Amount.Should().Be(1000);
                transaction.Status.Should().Be("paid");
            }
        }

        [Test]
        public void ShouldBeAbleToCreateTransactionFromPaypal()
        {
            var payPalTransaction = new PaypalTransaction(7897897, 1000, "S");
            var transaction = new PayPalTransactionAdapter(payPalTransaction);

            using (new AssertionScope())
            {
                transaction.TrackNumber.Should().Be("7897897");
                transaction.Amount.Should().Be(1000);
                transaction.Status.Should().Be("paid");
            }
        }
```
---

## Behavioral

### Chain of Responsability ###
- Cadeia de responsabilidade √© um design pattern comportamental que permite que passem as requisi√ß√µes adiante, como uma cadeia. E cada requisi√ß√£o/handle decide o que vai ser feito na cadeia.
- Especialmente √∫til quando tem que executar passos em sequ√™ncia.
- Os handlers s√£o conectados a uma cadeia e cada conex√£o do handler tem um campo que guarda a refer√™ncia para o pr√≥ximo handler.
Examples:
- Quando voc√™ quer oferecer um cart√£o de cr√©dio, mas precisa executar diversas valida√ß√µes antes para saber se a pessoa √© eleg√≠vel.
- Quando voc√™ precisa verificar se os usu√°rios est√£o autenticados e autorizados para acessar o sistema. Ent√£o, voc√™ pode usar cadeia de responsabilidade, quando o request √© criado e executado em sequ√™ncia o processo de autentica√ß√£o.

**PROS**
- Controlar a ordem de execu√ß√£o do request.
- Responsabilidade √önica: Desacople classes que invocam opera√ß√£o de classes que performam opera√ß√µes.
- Princ√≠pio do aberto fechado: Introduza novos handlers sem quebrar o c√≥digo cliente j√° existente.

**CONS**
- Risco de criar uma cadeia infinita.
- Depura√ß√£o pode ser mais dif√≠cil.
- A configura√ß√£o da cadeia pode ser complexa.

**Como implementar?**
- Declare a interface do handler e descreva a assinatura do seu m√©todo para lidar com as requisi√ß√µes do handler. Voc√™ pode converter as requisi√ß√µes em um objeto e passar o m√©todo do handler como um argumento.
- Para eliminar c√≥digo duplicado em handlers concretos, voc√™ pode criar uma classe abstrata base, derivada da interface do handler. Essa classe cont√©m uma refer√™ncia ao **pr√≥ximo handler** na cadeia. Considere fazer essa classe imut√°vel, mas se voc√™ precisa modificar cadeias em tempo de execu√ß√£o, voc√™ precisa definir um setter para alterar o campo de refer√™ncia. Al√©m disso, voc√™ vai precisar criar um comportamento padr√£o para o m√©todo do handler, que √© passar o request para o pr√≥ximo objeto a menos que n√£o haja objeto. Handlers concretos poder√£o usar isso chamando o m√©todo pai.
- Voc√™ pode criar suas pr√≥prias cadeias, receber cadeias pr√© constru√≠das de outros objetos ou implementar algumas classes factory para construir a cadeia.
- Clientes devem estar preparados para os seguintes cen√°rios: a cadeia consiste de um √∫nico link, aguns request n√£o devem seguir ao fim da cadeia e outras podem chegar ao fim da cadeia sem tratamento.

### Visitor ###
- Visitor √© uma padr√£o de projeto comportamental que executa uma opera√ß√£o em uma lista de objetos diferentes da mesma classe m√£e.
- √â usado quando voc√™ tem diferentes objetos dentro de uma lista ou √°rvore.

**PROS**
- Princ√≠pio do aberto fechado: porque voc√™ pode introduzir novos comportamentos para objetos espec√≠ficos sem mudar a classe pai.
- Princ√≠pio da responsabilidade √∫nica: porque voc√™ pode separar comportamento com sua classe respectiva.
- Visitor pode acumular informa√ß√µes e ser muito √∫til quando se trabalha com n√≥s de √°rvore.

**CONS**
- Voc√™ precisa atualizar todos os visitors quando uma classe √© modificada na hierarquia.
- Visitors podem n√£o ter os acessos necess√°rios para campos privados ou m√©todos.

**Como implementar?**
- Declare uma interface visitor com m√©todos visits, uma para elemento concreto da classe.
- Declare uma classe abstrata ou uma interface com os m√©todos Accept que ir√£o receber objetos visitors como argumento.
- Implemente os m√©todos Accept em todas as classes concretas. Esses m√©todos ir√£o redirecionar cada chamada do objeto visitor como um argumento.
- As classes de elementos somente trabalham com o visitor via interface do visitor. Visitors devem saber de todas os elementos concretos da classe como tipos de par√¢metro.
- Para cada comportamento na lista ou √°rvore, voc√™ tem que criar uma classe concreta do visitor e implementar os m√©todos visits.
- O cliente deve criar objetos visitors e pass√°-los para elementos por meio de m√©todos de aceita√ß√£o.

## üß™ Techs

This project was develop with the following technologies:

- [.NET 7 Console Application](https://docs.microsoft.com/pt-br/dotnet/core/dotnet-7)

## How can I use?

You will need of the Visual Studio 2022 and .NET 7 SDK.
This SKDs and tools can be download in .NET 7 https://dot.net/core.
You can execute in Visual Studio Code too (Windows, Linux or MacOS)

## üöÄ How can I execute?

Clone the projet and access the pasta.

```bash
$ git clone https://github.com/rafaelaccampos/design-patterns-in-csharp
$ cd DesignPatterns
# To install the dependencies
$ dotnet restore


```

To initiate the tests, follow the steps below:
```bash
$ dotnet test
```


