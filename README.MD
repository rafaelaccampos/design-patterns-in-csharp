<h1 align="center">Design Patterns in C#</h1>

## üíª Project
Esse projeto tem como objetivo estudar Design Patterns implementados em C#. Ele cont√©m teoria e a implementa√ß√£o do c√≥digo.
This project has the goal to study design patterns implemented in C#. It's contain theory and code implementation.

## Structural

### Adapter ###
Adapter √© um padr√£o de projeto estrutural que permite que classes incompat√≠veis se comuniquem. Ele tamb√©m serve como uma camada anticorrup√ß√£o que permite desacoplamento.
**Exemplos**:
- Diferentes implementa√ß√µes de gateway que tem que se comunicar com seu dom√≠nio que tem diferentes interfaces.
- Quando voc√™ tem c√≥digo legado e precisa adaptar para classes modernas.

**PROS**
- Responsabilidade √∫nica: Separar diferentes dados das regras de neg√≥cio.
- Princ√≠pio do aberto fechado: Voc√™ consegue introduzir novos adaptadores sem quebrar os clientes existentes, contanto que o contrato da interface seja preservada.

**CONS**
- A complexidade do c√≥digo aumenta porque √© introduzido muitas novas interfaces e classes.

**Como implementa?**
- Cria uma interface que descreve o contrato que outras classes devem seguir.

```csharp
namespace DesignPatterns.Structural.Adapter.Adapter_Transaction
{
    public interface ITransaction
    {
        public string TrackNumber { get; }
        public decimal Amount { get; }
        public string Status { get; }
    }
}
```

- Criar as classes desejadas.

```csharp
    public class PaypalTransaction
    {
        public PaypalTransaction(int id, int amount, string status)
        {
            Id = id;
            Amount = amount;
            Status = status;
        }

        public int Id { get; private set; }
        public decimal Amount { get; private set; }
        public string Status { get; private set; }
    }
```
```csharp
    public class StripeTransaction
    {
        public StripeTransaction(string code, decimal grossAmount, int situation)
        {
            Code = code;
            GrossAmount = grossAmount;
            Situation = situation;
        }

        public string Code { get; private set; }
        public decimal GrossAmount { get; private set; }
        public int Situation { get; private set; }
    }
```
- Criar o adaptador para as classes desejadas que v√£o implementar a interface.

```csharp
    public class PayPalTransactionAdapter : ITransaction
    {
        public PayPalTransactionAdapter(PaypalTransaction payPalTransaction)
        {
            TrackNumber = payPalTransaction.Id.ToString();
            Amount = payPalTransaction.Amount;
            Status = ConvertStatus(payPalTransaction.Status);
        }

        public string TrackNumber { get; private set; }

        public decimal Amount { get; private set; }

        public string Status { get; private set; }

        public string ConvertStatus(string status)
        {
            switch (status)
            {
                case "P":
                    return "waiting_payment";
                case "S":
                    return "paid";
                case "F":
                    return "refunded";
                default:
                    return string.Empty;
            }
        }
    }
```
```csharp
        public StripeTransactionAdapter(StripeTransaction stripeTransaction)
        {
            TrackNumber = stripeTransaction.Code;
            Amount = stripeTransaction.GrossAmount;
            Status = ConvertStatus(stripeTransaction.Situation);
        }

        public string TrackNumber { get; private set; }

        public decimal Amount { get; private set; }

        public string Status { get; private set; }

        public string ConvertStatus(int status)
        {
            switch (status)
            {
                case 1:
                    return "waiting_payment";
                case 2:
                    return "paid";
                case 3:
                    return "cancelled";
                default:
                    return string.Empty;
            }
        }
```
- Adicionar a refer√™ncia da classe que voc√™ precisar adaptar na sua classe adaptadora. √â comum usar o construtor, mas voc√™ pode chamar quando chamar o m√©todo das suas classes.

```csharp
        [Test]
        public void ShouldBeAbleToCreateTransactionFromStripe()
        {
            var stripeTransaction = new StripeTransaction("AHN765NHD89", 1000, 2);
            var transaction = new StripeTransactionAdapter(stripeTransaction);

            using (new AssertionScope())
            {
                transaction.TrackNumber.Should().Be("AHN765NHD89");
                transaction.Amount.Should().Be(1000);
                transaction.Status.Should().Be("paid");
            }
        }

        [Test]
        public void ShouldBeAbleToCreateTransactionFromPaypal()
        {
            var payPalTransaction = new PaypalTransaction(7897897, 1000, "S");
            var transaction = new PayPalTransactionAdapter(payPalTransaction);

            using (new AssertionScope())
            {
                transaction.TrackNumber.Should().Be("7897897");
                transaction.Amount.Should().Be(1000);
                transaction.Status.Should().Be("paid");
            }
        }
```
---

## Behavioral

### Chain of Responsability ###
- Cadeia de responsabilidade √© um design pattern comportamental que permite que passem as requisi√ß√µes adiante, como uma cadeia. E cada requisi√ß√£o/handle decide o que vai ser feito na cadeia.
- Especialmente √∫til quando tem que executar passos em sequ√™ncia.
- Os handlers s√£o conectados a uma cadeia e cada conex√£o do handler tem um campo que guarda a refer√™ncia para o pr√≥ximo handler.
Examples:
- Quando voc√™ quer oferecer um cart√£o de cr√©dio, mas precisa executar diversas valida√ß√µes antes para saber se a pessoa √© eleg√≠vel.
- Quando voc√™ precisa verificar se os usu√°rios est√£o autenticados e autorizados para acessar o sistema. Ent√£o, voc√™ pode usar cadeia de responsabilidade, quando o request √© criado e executado em sequ√™ncia o processo de autentica√ß√£o.

**PROS**
- Controlar a ordem de execu√ß√£o do request.
- Responsabilidade √∫nica: Desacople classes que invocam opera√ß√£o de classes que performam opera√ß√µes.
- Princ√≠pio do aberto fechado: Introduza novos handlers sem quebrar o c√≥digo cliente j√° existente.

**CONS**
- Risco de criar uma cadeia infinita.
- Depura√ß√£o pode ser mais dif√≠cil.
- A configura√ß√£o da cadeia pode ser complexa.

**Como implementar?**
- Declare a interface do handler e descreva a assinatura do seu m√©todo para lidar com as requisi√ß√µes do handler. Voc√™ pode converter as requisi√ß√µes em um objeto e passar no m√©todo do handler como um argumento.

```csharp
namespace DesignPatterns.Behavioral.Chain_of_Responsability_Adm
{
    public interface IHandler
    {
        void Handle(IList<Bill> bills, int amount);
    }
}
```

- Para eliminar c√≥digo duplicado em handlers concretos, voc√™ pode criar uma classe abstrata base, derivada da interface do handler. Essa classe cont√©m uma refer√™ncia ao **pr√≥ximo handler** na cadeia. Considere fazer essa classe imut√°vel, mas se voc√™ precisa modificar cadeias em tempo de execu√ß√£o, voc√™ precisa definir um setter para alterar o campo de refer√™ncia. Al√©m disso, voc√™ vai precisar criar um comportamento padr√£o para o m√©todo do handler, que √© passar o request para o pr√≥ximo objeto a menos que n√£o haja objeto. Handlers concretos poder√£o usar isso chamando o m√©todo pai.

```csharp
using static System.Runtime.InteropServices.JavaScript.JSType;

namespace DesignPatterns.Behavioral.Chain_of_Responsability_Adm
{
    public class BillHandler : IHandler
    {
        private readonly IHandler? _nextHandler;
        private readonly int _type;
       
        public BillHandler(IHandler? nextHandler, int type)
        {
            _nextHandler = nextHandler;
            _type = type;
        }

        public void Handle(IList<Bill> bills, int amount)
        {
            decimal notes = amount / _type;
            var count = (int)Math.Floor(notes);
            var bill = new Bill
            {
                Count = count,
                Type = _type,
            };

            bills.Add(bill);
            var remaining = amount % _type;

            if (_nextHandler != null)
            {
                _nextHandler.Handle(bills, remaining);
                return;
            }
            if (remaining > 0) throw new Exception("Without available notes!");
        }
    }
}
```

- Voc√™ pode criar suas pr√≥prias cadeias, receber cadeias pr√© constru√≠das de outros objetos ou implementar algumas classes factory para construir a cadeia.

```csharp
namespace DesignPatterns.Behavioral.Chain_of_Responsability_Adm
{
    public class Bill
    {
        public int Type { get; set; }
        public int Count { get; set; }
    }
}

namespace DesignPatterns.Behavioral.Chain_of_Responsability_Adm
{
    public class Atm
    {
        private readonly IHandler _handler;

        public Atm(IHandler handler)
        {
            _handler = handler;
        }

        public IList<Bill> Withdraw(int amount)
        {
            var bills = new List<Bill>();
            _handler.Handle(bills, amount);
            return bills;
        }
    }
}
```
- Clientes devem estar preparados para os seguintes cen√°rios: a cadeia consiste de um √∫nico link, aguns request n√£o devem seguir ao fim da cadeia e outras podem chegar ao fim da cadeia sem tratamento.

```csharp
using DesignPatterns.Behavioral.Chain_of_Responsability_Adm;
using FluentAssertions;

namespace DesignPatterns.Tests.Chain_of_Responsability
{
    public class AtmTests
    {
        [Test]
        public void ShouldBeAbleToRetrieveMoneyWithAllNotes()
        {
            var handler1 = new BillHandler(null, 1);
            var handler2 = new BillHandler(handler1, 2);
            var handler5 = new BillHandler(handler2, 5);
            var handler10 = new BillHandler(handler5, 10);
            var handler20 = new BillHandler(handler10, 20);
            var handler50 = new BillHandler(handler20, 50);
            var handler100 = new BillHandler(handler50, 100);
            var atm = new Atm(handler100);

            var bills = atm.Withdraw(978);

            var expectedBills = new List<Bill>
            {
                { new Bill { Count = 9, Type = 100 } },
                { new Bill { Count = 1, Type = 50 } },
                { new Bill { Count = 1, Type = 20 } },
                { new Bill { Count = 0, Type = 10 } },
                { new Bill { Count = 1, Type = 5 } },
                { new Bill { Count = 1, Type = 2 } },
                { new Bill { Count = 1, Type = 1 } },
            };

            bills.Should().BeEquivalentTo(expectedBills);
        }

        [Test]
        public void ShouldBeAbleToRetrieveMoneyWithOnlyOneNotes()
        {
            var handler1 = new BillHandler(null, 1);
            var atm = new Atm(handler1);

            var bills = atm.Withdraw(978);

            var expectedBills = new List<Bill>
            {
                { new Bill { Count = 978, Type = 1 } },
            };

            bills.Should().BeEquivalentTo(expectedBills);
        }

        [Test]
        public void ShouldBeAbleToRetrieveMoneyWithOnlyFiveAndTenNotes()
        {
            var handler5 = new BillHandler(null, 5);
            var handler10 = new BillHandler(handler5, 10);

            var atm = new Atm(handler10);
            var bills = atm.Withdraw(500);

            var expectedBills = new List<Bill>
            {
                { new Bill { Count = 50, Type = 10 } },
                { new Bill { Count = 0, Type = 5 } },
            };

            bills.Should().BeEquivalentTo(expectedBills);
        }
    }
}
```

### Visitor ###
- Visitor √© uma padr√£o de projeto comportamental que executa uma opera√ß√£o em uma lista de objetos diferentes da mesma classe m√£e.
- √â usado quando voc√™ tem diferentes objetos dentro de uma lista ou √°rvore.

**PROS**
- Princ√≠pio do aberto fechado: porque voc√™ pode introduzir novos comportamentos para objetos espec√≠ficos sem mudar a classe pai.
- Princ√≠pio da responsabilidade √∫nica: porque voc√™ pode separar comportamento com sua classe respectiva.
- Visitor pode acumular informa√ß√µes e ser muito √∫til quando se trabalha com n√≥s de √°rvore.

**CONS**
- Voc√™ precisa atualizar todos os visitors quando uma classe √© modificada na hierarquia.
- Visitors podem n√£o ter os acessos necess√°rios para campos privados ou m√©todos.

**Como implementar?**
- Declare uma interface visitor com m√©todos visits, uma para elemento concreto da classe.

```csharp
namespace DesignPatterns.Behavioral.Visitor_Marketing
{
    public interface INotificationVisitor
    {
        string Visit(SmsMessage message);

        string Visit(EmailMessage message);
    }
}
```

- Declare uma classe abstrata ou uma interface com os m√©todos Accept que ir√£o receber objetos visitors como argumento.

```csharp
namespace DesignPatterns.Behavioral.Visitor_Marketing
{
    public interface IMarketingMessage
    {
        string From { get; }

        string To { get; }

        string Content { get; }

        string Accept(INotificationVisitor visitor);
    }
}
```

- Implemente os m√©todos Accept em todas as classes concretas. Esses m√©todos ir√£o redirecionar cada chamada do objeto visitor como um argumento.

```csharp
namespace DesignPatterns.Behavioral.Visitor_Marketing
{
    public class EmailMessage : IMarketingMessage
    {
        public EmailMessage(string from, string to, string subject, string content)
        {
            From = from;
            To = to;
            Subject = subject;
            Content = content;
        }

        public string From { get; private set; }

        public string To { get; private set; }

        public string Subject { get; private set; }

        public string Content { get; private set; }

        public string Accept(INotificationVisitor visitor)
        {
            return visitor.Visit(this);
        }
    }
}

namespace DesignPatterns.Behavioral.Visitor_Marketing
{
    public class SmsMessage : IMarketingMessage
    {
        public SmsMessage(string from, string to, string content)
        {
            From = from;
            To = to;
            Content = content;
        }

        public string From { get; private set; }

        public string To { get; private set; }

        public string Content { get; private set; }

        public string Accept(INotificationVisitor visitor)
        {
            return visitor.Visit(this);
        }
    }
}
```

- As classes de elementos somente trabalham com o visitor via interface do visitor. Visitors devem saber de todas os elementos concretos da classe como tipos de par√¢metro.
- Para cada comportamento na lista ou √°rvore, voc√™ tem que criar uma classe concreta do visitor e implementar os m√©todos visits.

```csharp
namespace DesignPatterns.Behavioral.Visitor_Marketing
{
    public class NotificationVisitor : INotificationVisitor
    {
        public string Visit(SmsMessage message)
        {
            return $"SMS message: From: {message.From}, To: {message.To}, Content: {message.Content}";
        }

        public string Visit(EmailMessage message)
        {
            return $"Email message: From: {message.From}, Subject: {message.Subject}, To: {message.To}, Content: {message.Content}";
        }
    }
}
namespace DesignPatterns.Behavioral.Visitor_Marketing
{
    public class NotificationService
    {
        private readonly INotificationVisitor _notificationVisitor;

        public NotificationService(INotificationVisitor notificationVisitor)
        {
            _notificationVisitor = notificationVisitor;
        }

        public IEnumerable<string> Notify(IList<IMarketingMessage> messages)
        {
            var visitor = _notificationVisitor;

            foreach (var message in messages)
            {
                yield return message.Accept(visitor);
            }
        }
    }
}
```
- O cliente deve criar objetos visitors e pass√°-los para elementos por meio de m√©todos de aceita√ß√£o.

```csharp
using DesignPatterns.Behavioral.Visitor_Marketing;
using FluentAssertions;
using FluentAssertions.Execution;

namespace DesignPatterns.Tests.Visitor
{
    public class NotificationServiceTests
    {
        [Test]
        public void ShouldBeAbleToCreateEmailMessageNotification()
        {
            var emailMessages = new List<IMarketingMessage>
            {
                new EmailMessage("Rafa", "T", "BFF", "We need to go out sometime!"),
            };

            var notificationVisitor = new NotificationVisitor();
            var notificationService = new NotificationService(notificationVisitor);
            var notifications = notificationService.Notify(emailMessages).ToList();

            var expectedEmailMessage = "Email message: From: Rafa, Subject: BFF, To: T, Content: We need to go out sometime!";
            using (new AssertionScope())
            {
                notifications.Should().BeEquivalentTo(expectedEmailMessage);
            }
        }

        [Test]
        public void ShouldBeAbleToCreateSMSMessageNotification()
        {
            var smsMessages = new List<IMarketingMessage>
            {
                new SmsMessage("T", "Rafa", "Definitely, we need to schedule!"),
            };

            var notificationVisitor = new NotificationVisitor();
            var notificationService = new NotificationService(notificationVisitor);
            var notifications = notificationService.Notify(smsMessages).ToList();

            var expectedSmsMessage = "SMS message: From: T, To: Rafa, Content: Definitely, we need to schedule!";
            using (new AssertionScope())
            {
                notifications.Should().BeEquivalentTo(expectedSmsMessage);
            }
        }

        [Test]
        public void ShouldBeAbleToCreateEmailAndSmsMessagesNotifications()
        {
            var emailMessage = new EmailMessage("Rafa", "T", "BFF", "We need to go out sometime!");
            var smsMessage = new SmsMessage("T", "Rafa", "Definitely, we need to schedule!");

            var messages = new List<IMarketingMessage>
            {
                emailMessage,
                smsMessage
            };

            var notificationVisitor = new NotificationVisitor();
            var notificationService = new NotificationService(notificationVisitor);
            var notifications = notificationService.Notify(messages).ToList();

            var expectedMessages = new List<string>
            {
                { "Email message: From: Rafa, Subject: BFF, To: T, Content: We need to go out sometime!" },
                { "SMS message: From: T, To: Rafa, Content: Definitely, we need to schedule!" },
            };

            using (new AssertionScope())
            {
                notifications.Should().Contain(expectedMessages);
            }
        }
    }
}
```

## üß™ Techs

This project was develop with the following technologies:

- [.NET 7 Console Application](https://docs.microsoft.com/pt-br/dotnet/core/dotnet-7)

## How can I use?

You will need of the Visual Studio 2022 and .NET 7 SDK.
This SKDs and tools can be download in .NET 7 https://dot.net/core.
You can execute in Visual Studio Code too (Windows, Linux or MacOS)

## üöÄ How can I execute?

Clone the projet and access the pasta.

```bash
$ git clone https://github.com/rafaelaccampos/design-patterns-in-csharp
$ cd DesignPatterns
# To install the dependencies
$ dotnet restore


```

To initiate the tests, follow the steps below:
```bash
$ dotnet test
```


